# P1.1 - VARIANTS P√âDAGOGIQUES (A/B/C) - GUIDE D'IMPL√âMENTATION

**Date**: 23 d√©cembre 2025  
**Statut**: üü° EN COURS (param√®tre ajout√©, logique √† impl√©menter)  
**Objectif**: Diff√©renciation p√©dagogique sans changer le niveau math√©matique

---

## üéØ OBJECTIF

Permettre √† un m√™me g√©n√©rateur de produire 3 variants d'un m√™me exercice:
- **A (Standard/Autonome)**: √ânonc√© direct, solution compl√®te mais concise
- **B (Guid√©)**: √ânonc√© avec indices/questions interm√©diaires, solution tr√®s d√©taill√©e
- **C (Diagnostic)**: √ânonc√© propose une r√©ponse √† v√©rifier/justifier

**Contrainte**: M√™me difficult√© = m√™me niveau math√©matique. Le variant change la **p√©dagogie**, pas le **calcul**.

---

## ‚úÖ CE QUI EST D√âJ√Ä FAIT

### 1. Param√®tre `variant_id` ajout√© au sch√©ma

**Fichiers modifi√©s**:
- `backend/generators/raisonnement_multiplicatif_v1.py`
- `backend/generators/calcul_nombres_v1.py`

```python
ParamSchema(
    name="variant_id",
    type=ParamType.ENUM,
    description="Variant p√©dagogique (P1.1)",
    default="A",
    options=["A", "B", "C"],
    required=False
)
```

**Impact**: Le param√®tre est maintenant disponible dans `params` lors de la g√©n√©ration.

---

## üìã CE QU'IL RESTE √Ä FAIRE

### √âTAPE 1 : Extraire `variant_id` dans la m√©thode `generate()`

**Fichier**: `backend/generators/raisonnement_multiplicatif_v1.py`  
**M√©thode**: `generate(self, params: Dict[str, Any])`

```python
def generate(self, params: Dict[str, Any]) -> Dict[str, Any]:
    # Extraire les param√®tres
    exercise_type = params.get("exercise_type", "proportionnalite_tableau")
    difficulty = params.get("difficulty", "moyen")
    grade = params.get("grade", "6e")
    seed = params.get("seed")
    variant_id = params.get("variant_id", "A")  # ‚Üê AJOUTER ICI
    
    # ... validation ...
    
    # Passer variant_id aux m√©thodes _generate_*
    if exercise_type == "proportionnalite_tableau":
        variables = self._generate_proportionnalite_tableau(difficulty, grade, variant_id)
    elif exercise_type == "pourcentage":
        variables = self._generate_pourcentage(difficulty, grade, variant_id)
    # ... etc
```

---

### √âTAPE 2 : Cr√©er des helpers pour adapter √©nonc√©/solution

**Fichier**: `backend/generators/raisonnement_multiplicatif_v1.py`  
**Nouvelle m√©thode** (√† ajouter apr√®s `_build_tableau_html`)

```python
def _adapt_enonce_variant(
    self, 
    base_enonce: str, 
    variant_id: str, 
    exercise_context: Dict[str, Any]
) -> str:
    """
    Adapte l'√©nonc√© selon le variant p√©dagogique.
    
    Args:
        base_enonce: √ânonc√© de base (variant A)
        variant_id: "A", "B", ou "C"
        exercise_context: Contexte de l'exercice (donn√©es, valeurs, etc.)
    
    Returns:
        √ânonc√© adapt√© au variant
    """
    if variant_id == "A":
        # Standard: √©nonc√© direct
        return base_enonce
    
    elif variant_id == "B":
        # Guid√©: ajouter des indices/questions interm√©diaires
        hints = []
        
        # Exemple pour proportionnalit√©
        if "coefficient" in exercise_context:
            hints.append("üí° Indice 1 : Commence par trouver le coefficient de proportionnalit√©.")
            hints.append("üí° Indice 2 : Divise une valeur de la ligne 2 par la valeur correspondante de la ligne 1.")
            hints.append("üí° Indice 3 : Multiplie la valeur de la ligne 1 par ce coefficient.")
        
        hints_text = "<br>".join(hints)
        return f"{base_enonce}<br><br><strong>Pour t'aider :</strong><br>{hints_text}"
    
    elif variant_id == "C":
        # Diagnostic: proposer une r√©ponse √† v√©rifier
        if "reponse_proposee" in exercise_context:
            reponse = exercise_context["reponse_proposee"]
            correct = exercise_context.get("reponse_correcte", True)
            
            return f"{base_enonce}<br><br><strong>Un √©l√®ve propose :</strong> {reponse}<br><br>Cette r√©ponse est-elle correcte ? Justifie ta r√©ponse."
        else:
            # Fallback si pas de r√©ponse propos√©e
            return base_enonce
    
    return base_enonce


def _adapt_solution_variant(
    self, 
    base_solution: str, 
    base_calculs: str,
    variant_id: str, 
    exercise_context: Dict[str, Any]
) -> tuple[str, str]:
    """
    Adapte la solution selon le variant p√©dagogique.
    
    Args:
        base_solution: Solution de base (variant A)
        base_calculs: Calculs interm√©diaires de base
        variant_id: "A", "B", ou "C"
        exercise_context: Contexte de l'exercice
    
    Returns:
        (solution_adapt√©e, calculs_adapt√©s)
    """
    if variant_id == "A":
        # Standard: solution compl√®te mais concise
        return base_solution, base_calculs
    
    elif variant_id == "B":
        # Guid√©: solution tr√®s d√©taill√©e avec explications
        calculs_detailles = base_calculs.replace("√âtape", "üìù √âtape")
        calculs_detailles += "\n\n‚úÖ V√©rification : Tous les calculs sont corrects."
        
        solution_detaillee = base_solution + "\n\nüí° Explication : " + \
            "En proportionnalit√©, toutes les valeurs sont multipli√©es par le m√™me coefficient. " + \
            "C'est pourquoi on divise d'abord pour trouver ce coefficient, puis on multiplie."
        
        return solution_detaillee, calculs_detailles
    
    elif variant_id == "C":
        # Diagnostic: justification de la r√©ponse
        correct = exercise_context.get("reponse_correcte", True)
        
        if correct:
            solution_diagnostic = f"‚úÖ La r√©ponse propos√©e est CORRECTE.\n\n{base_solution}"
        else:
            solution_diagnostic = f"‚ùå La r√©ponse propos√©e est INCORRECTE.\n\n{base_solution}\n\n" + \
                f"Erreur identifi√©e : {exercise_context.get('erreur_commise', 'Calcul erron√©')}"
        
        return solution_diagnostic, base_calculs
    
    return base_solution, base_calculs
```

---

### √âTAPE 3 : Adapter chaque m√©thode `_generate_*`

**Exemple pour `_generate_proportionnalite_tableau`**

#### Avant (actuel)
```python
def _generate_proportionnalite_tableau(self, difficulty: str, grade: str) -> Dict[str, Any]:
    # ... g√©n√©ration des valeurs ...
    
    enonce = f"{intro}<br><br>Quelle est la valeur manquante ?"
    
    return {
        "enonce": enonce,
        "consigne": self.rng_choice(self._CONSIGNE_VARIANTS["proportionnalite_tableau"]),
        "solution": solution,
        "calculs_intermediaires": calculs,
        "reponse_finale": str(valeur_a_trouver),
        # ...
    }
```

#### Apr√®s (avec variants)
```python
def _generate_proportionnalite_tableau(
    self, 
    difficulty: str, 
    grade: str, 
    variant_id: str = "A"
) -> Dict[str, Any]:
    # ... g√©n√©ration des valeurs (INCHANG√â) ...
    
    # √ânonc√© de base (variant A)
    base_enonce = f"{intro}<br><br>Quelle est la valeur manquante ?"
    
    # Contexte pour les variants
    exercise_context = {
        "coefficient": coeff,
        "valeur_base": valeurs_base[index_a_trouver],
        "valeur_a_trouver": valeur_a_trouver,
        "reponse_proposee": None,  # √Ä g√©n√©rer pour variant C
        "reponse_correcte": True,
    }
    
    # Variant C : g√©n√©rer une r√©ponse propos√©e (correcte ou incorrecte)
    if variant_id == "C":
        if self._rng.random() < 0.5:
            # Proposer la bonne r√©ponse
            exercise_context["reponse_proposee"] = str(valeur_a_trouver)
            exercise_context["reponse_correcte"] = True
        else:
            # Proposer une r√©ponse erron√©e (erreur classique: addition au lieu de multiplication)
            reponse_erronee = valeurs_base[index_a_trouver] + coeff
            exercise_context["reponse_proposee"] = str(reponse_erronee)
            exercise_context["reponse_correcte"] = False
            exercise_context["erreur_commise"] = "Addition au lieu de multiplication"
    
    # Adapter l'√©nonc√© selon le variant
    enonce = self._adapt_enonce_variant(base_enonce, variant_id, exercise_context)
    
    # Adapter la solution selon le variant
    solution_adaptee, calculs_adaptes = self._adapt_solution_variant(
        solution, calculs, variant_id, exercise_context
    )
    
    return {
        "enonce": enonce,
        "consigne": self.rng_choice(self._CONSIGNE_VARIANTS["proportionnalite_tableau"]),
        "solution": solution_adaptee,
        "calculs_intermediaires": calculs_adaptes,
        "reponse_finale": str(valeur_a_trouver),
        "donnees": donnees,
        "tableau_html": tableau_html,
        "methode": "coefficient_de_proportionnalite",
        "niveau": grade,
        "type_exercice": "proportionnalite_tableau",
        "variant_id": variant_id,  # ‚Üê AJOUTER pour tra√ßabilit√©
    }
```

---

### √âTAPE 4 : R√©p√©ter pour les autres types d'exercices

Appliquer la m√™me logique √†:
- `_generate_pourcentage`
- `_generate_vitesse`
- `_generate_echelle`
- Tous les types de `CALCUL_NOMBRES_V1`

---

## üß™ TESTS √Ä CR√âER

**Fichier**: `backend/tests/test_variants_pedagogiques.py`

```python
"""Tests pour les variants p√©dagogiques A/B/C"""
import pytest
from backend.generators.raisonnement_multiplicatif_v1 import RaisonnementMultiplicatifV1Generator

class TestVariantsPedagogiques:
    """Tests des variants A/B/C."""
    
    def test_variant_a_standard(self):
        """Variant A : √©nonc√© direct, solution concise."""
        gen = RaisonnementMultiplicatifV1Generator(seed=42)
        result = gen.generate({
            "exercise_type": "proportionnalite_tableau",
            "difficulty": "moyen",
            "grade": "6e",
            "variant_id": "A",
            "seed": 42
        })
        
        variables = result["variables"]
        assert variables["variant_id"] == "A"
        assert "üí° Indice" not in variables["enonce"]  # Pas d'indices en A
        assert "Un √©l√®ve propose" not in variables["enonce"]  # Pas de diagnostic en A
    
    def test_variant_b_guide(self):
        """Variant B : √©nonc√© avec indices, solution d√©taill√©e."""
        gen = RaisonnementMultiplicatifV1Generator(seed=42)
        result = gen.generate({
            "exercise_type": "proportionnalite_tableau",
            "difficulty": "moyen",
            "grade": "6e",
            "variant_id": "B",
            "seed": 42
        })
        
        variables = result["variables"]
        assert variables["variant_id"] == "B"
        assert "üí° Indice" in variables["enonce"]  # Indices pr√©sents
        # Solution plus d√©taill√©e
        assert len(variables["solution"]) > len(self.test_variant_a_standard().variables["solution"])
    
    def test_variant_c_diagnostic(self):
        """Variant C : √©nonc√© avec r√©ponse propos√©e √† v√©rifier."""
        gen = RaisonnementMultiplicatifV1Generator(seed=42)
        result = gen.generate({
            "exercise_type": "proportionnalite_tableau",
            "difficulty": "moyen",
            "grade": "6e",
            "variant_id": "C",
            "seed": 42
        })
        
        variables = result["variables"]
        assert variables["variant_id"] == "C"
        assert "Un √©l√®ve propose" in variables["enonce"]  # Diagnostic pr√©sent
        assert ("‚úÖ" in variables["solution"] or "‚ùå" in variables["solution"])  # Verdict
    
    def test_determinisme_variants(self):
        """M√™me seed ‚Üí m√™me variant g√©n√©r√©."""
        gen1 = RaisonnementMultiplicatifV1Generator(seed=42)
        gen2 = RaisonnementMultiplicatifV1Generator(seed=42)
        
        result1 = gen1.generate({
            "exercise_type": "proportionnalite_tableau",
            "difficulty": "moyen",
            "grade": "6e",
            "variant_id": "B",
            "seed": 42
        })
        
        result2 = gen2.generate({
            "exercise_type": "proportionnalite_tableau",
            "difficulty": "moyen",
            "grade": "6e",
            "variant_id": "B",
            "seed": 42
        })
        
        assert result1["variables"]["enonce"] == result2["variables"]["enonce"]
```

---

## üìä ESTIMATIONS

| T√¢che | Complexit√© | Temps estim√© |
|-------|-----------|--------------|
| Helpers `_adapt_*` | Moyenne | 30min |
| Adapter `_generate_proportionnalite_tableau` | Faible | 20min |
| Adapter `_generate_pourcentage` | Faible | 20min |
| Adapter `_generate_vitesse` | Faible | 20min |
| Adapter `_generate_echelle` | Faible | 20min |
| Adapter `CALCUL_NOMBRES_V1` (3 types) | Moyenne | 1h |
| Tests complets | Moyenne | 45min |
| **TOTAL** | | **~3h** |

---

## üéØ PRIORIT√âS

### P0 (Critique)
- ‚úÖ Ajouter `variant_id` au sch√©ma
- Impl√©menter UN type d'exercice en exemple (proportionnalite_tableau)
- Tests de base pour valider le concept

### P1 (Important)
- √âtendre aux autres types d'exercices
- Tests complets pour tous les variants

### P2 (Nice to have)
- Interface admin pour pr√©visualiser les variants
- Statistiques d'utilisation des variants

---

## üöÄ COMMENCER MAINTENANT

Pour impl√©menter rapidement:

1. **Copier les helpers** `_adapt_enonce_variant` et `_adapt_solution_variant` dans `raisonnement_multiplicatif_v1.py`
2. **Modifier UNE m√©thode** `_generate_proportionnalite_tableau` selon l'exemple
3. **Tester** avec un appel API:
   ```bash
   curl -X POST http://localhost:8000/api/v1/exercises/generate \
     -d '{"code_officiel": "6e_SP03", "offer": "pro", "seed": 42, "variant_id": "B"}'
   ```
4. **Valider** que l'√©nonc√© contient les indices

---

## üìù NOTES

- Les variants ne changent PAS les valeurs num√©riques (d√©terminisme pr√©serv√©)
- Le variant C n√©cessite de g√©n√©rer une "r√©ponse propos√©e" (correcte ou fausse)
- Les templates HTML frontend (`ChapterExercisesAdminPage.js`) n'ont PAS besoin de changer
- Le `variant_id` est optionnel (default "A"), donc pas de breaking change

---

**Statut global P1.1**: üü° **30% COMPL√âT√â**  
- ‚úÖ Param√®tre ajout√©
- üîÑ Logique √† impl√©menter
- ‚è≥ Tests √† cr√©er








