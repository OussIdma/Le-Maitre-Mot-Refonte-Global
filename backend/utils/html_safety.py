"""
P0-B: HTML Safety Module - XSS Protection with bleach

Sanitizes HTML content to prevent XSS attacks while preserving:
- Safe text formatting tags (p, strong, table, etc.)
- SVG content generated by generators (trusted source, NOT sanitized)

Usage:
    from backend.utils.html_safety import sanitize_text_html, is_html_safe

    # Sanitize admin/user-provided HTML text
    safe_html = sanitize_text_html("<p>Hello <script>alert(1)</script></p>")
    # Returns: "<p>Hello </p>"

    # Check if HTML is safe
    result = is_html_safe("<p onclick='alert(1)'>Test</p>")
    # Returns: {"safe": False, "issues": ["Removed event handlers"]}
"""

import bleach
from typing import Dict, Any, List, Optional
import re


# P0-B: Whitelist of allowed tags for text HTML (NO SVG - SVG is trusted from generators)
ALLOWED_TAGS = [
    # Text formatting
    'p', 'div', 'span', 'br', 'hr',
    'strong', 'em', 'b', 'i', 'u', 's', 'sub', 'sup',
    # Lists
    'ul', 'ol', 'li',
    # Tables
    'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th', 'caption', 'colgroup', 'col',
    # Headings
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    # Other safe tags
    'blockquote', 'pre', 'code',
]

# P0-B: Whitelist of allowed attributes
ALLOWED_ATTRIBUTES = {
    '*': ['class'],  # class is safe (CSS only, no JS execution)
    'td': ['colspan', 'rowspan'],
    'th': ['colspan', 'rowspan', 'scope'],
    'col': ['span'],
    'colgroup': ['span'],
    'table': ['border'],  # Limited table attributes
}

# P0-B: Explicitly forbidden - NO href/src to prevent javascript: URLs
# If href/src are needed in the future, use protocols=['http', 'https', 'mailto']
ALLOWED_PROTOCOLS = ['http', 'https', 'mailto']


def sanitize_text_html(
    html: str,
    *,
    extra_tags: Optional[List[str]] = None,
    extra_attrs: Optional[Dict[str, List[str]]] = None,
    strip: bool = True,
    max_length: int = 300_000
) -> str:
    """
    Sanitize HTML text content (enonce, solution templates from admin/DB).

    IMPORTANT: Do NOT use this for SVG content from generators - SVG is trusted.

    Args:
        html: HTML string to sanitize
        extra_tags: Additional allowed tags (optional)
        extra_attrs: Additional allowed attributes (optional)
        strip: If True, remove disallowed tags entirely. If False, escape them.
        max_length: Maximum input length (protection against DoS)

    Returns:
        Sanitized HTML string

    Examples:
        >>> sanitize_text_html("<p>Hello</p>")
        '<p>Hello</p>'

        >>> sanitize_text_html("<script>alert(1)</script>")
        ''

        >>> sanitize_text_html("<p onclick='alert(1)'>Test</p>")
        '<p>Test</p>'

        >>> sanitize_text_html("<a href='javascript:alert(1)'>Link</a>")
        'Link'  # <a> not in allowed tags
    """
    if not html:
        return ""

    # DoS protection
    if len(html) > max_length:
        raise ValueError(f"HTML too large: {len(html)} > {max_length}")

    # Build tag list
    tags = list(ALLOWED_TAGS)
    if extra_tags:
        tags.extend(extra_tags)

    # Build attributes dict
    attrs = dict(ALLOWED_ATTRIBUTES)
    if extra_attrs:
        for tag, tag_attrs in extra_attrs.items():
            if tag in attrs:
                attrs[tag] = list(set(attrs[tag] + tag_attrs))
            else:
                attrs[tag] = tag_attrs

    # Pre-processing: Remove <script> and <style> blocks completely (tags + content)
    # Using (?is) flags: case-insensitive + dotall (dot matches newlines)
    # Using [\s\S]*? to match any character including newlines (more robust than .*?)
    html = re.sub(r'(?is)<script[^>]*>[\s\S]*?</script>', '', html)
    html = re.sub(r'(?is)<style[^>]*>[\s\S]*?</style>', '', html)

    # Use bleach to sanitize
    return bleach.clean(
        html,
        tags=tags,
        attributes=attrs,
        protocols=ALLOWED_PROTOCOLS,
        strip=strip
    )


def is_html_safe(html: str, *, max_length: int = 300_000) -> Dict[str, Any]:
    """
    Check if HTML is safe WITHOUT modifying it.

    Args:
        html: HTML to check
        max_length: Maximum input length

    Returns:
        {
            "safe": bool,
            "issues": List[str],  # List of detected issues
            "sanitized": str,     # What the sanitized version would look like
        }

    Examples:
        >>> is_html_safe("<p>Hello</p>")
        {"safe": True, "issues": [], "sanitized": "<p>Hello</p>"}

        >>> is_html_safe("<script>alert(1)</script>")
        {"safe": False, "issues": ["Removed <script> tags"], "sanitized": ""}
    """
    if not html:
        return {"safe": True, "issues": [], "sanitized": ""}

    if len(html) > max_length:
        return {
            "safe": False,
            "issues": ["HTML too large"],
            "sanitized": ""
        }

    issues = []

    # Check for script tags
    if re.search(r'<script', html, re.IGNORECASE):
        issues.append("Contains <script> tags")

    # Check for event handlers (onclick, onerror, etc.)
    if re.search(r'\bon\w+\s*=', html, re.IGNORECASE):
        issues.append("Contains event handler attributes (onclick, onerror, etc.)")

    # Check for javascript: URLs
    if re.search(r'javascript:', html, re.IGNORECASE):
        issues.append("Contains javascript: URLs")

    # Check for iframe/object/embed
    if re.search(r'<(iframe|object|embed)', html, re.IGNORECASE):
        issues.append("Contains dangerous tags (iframe, object, embed)")

    # Check for data: URLs (can be used for XSS)
    if re.search(r'data:\s*text/html', html, re.IGNORECASE):
        issues.append("Contains data: URLs with HTML")

    # Sanitize and compare
    sanitized = sanitize_text_html(html)

    # If sanitization changed the HTML significantly, it wasn't safe
    if sanitized.strip() != html.strip():
        if not issues:  # Add generic issue if specific ones not detected
            issues.append("HTML was modified during sanitization")

    return {
        "safe": len(issues) == 0,
        "issues": issues,
        "sanitized": sanitized
    }


def sanitize_template_html(
    enonce_html: str,
    solution_html: str
) -> Dict[str, str]:
    """
    Sanitize both enonce and solution templates.

    Convenience function for sanitizing admin templates before storage.

    Args:
        enonce_html: Enonce template HTML
        solution_html: Solution template HTML

    Returns:
        {"enonce_html": sanitized_enonce, "solution_html": sanitized_solution}
    """
    return {
        "enonce_html": sanitize_text_html(enonce_html),
        "solution_html": sanitize_text_html(solution_html)
    }


# P0-B: SVG handling - SVG from generators is TRUSTED
# This function is intentionally a pass-through for documentation purposes
def trust_generator_svg(svg: str) -> str:
    """
    Mark SVG from generator as trusted (pass-through).

    SVG content from generators is trusted because:
    - It's generated by our code, not user input
    - It's needed for geometric figures
    - Sanitizing would break the SVG

    Args:
        svg: SVG string from generator

    Returns:
        Same SVG string (unmodified)
    """
    # P0-B: Intentionally NOT sanitizing - generator SVG is trusted
    return svg
