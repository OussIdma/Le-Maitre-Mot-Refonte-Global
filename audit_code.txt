# ============================================================================
# AUDIT CODE CRITIQUE - S√©lection DYNAMIC vs STATIC
# ============================================================================
# Fichiers concat√©n√©s pour audit P0
# Date: 2025-12-25
# ============================================================================


# ============================================================================
# 1. backend/routes/exercises_routes.py
# ============================================================================

"""
Routes API v1 pour la g√©n√©ration d'exercices
Endpoint: POST /api/v1/exercises/generate
Endpoint batch: POST /api/v1/exercises/generate/batch (GM07 uniquement)

Modes de fonctionnement:
1. Mode GM07 (chapitre pilote): exercices fig√©s depuis gm07_exercises.py
2. Mode legacy: niveau + chapitre (comportement existant)
3. Mode officiel: code_officiel (bas√© sur le r√©f√©rentiel 6e)
"""
from fastapi import APIRouter, HTTPException
from typing import Optional, List, Any, Dict
from pydantic import BaseModel, Field
from html import escape
import time
import re

from backend.models.exercise_models import (
    ExerciseGenerateRequest,
    ExerciseGenerateResponse,
    ErrorDetail
)
from backend.models.math_models import MathExerciseType
from backend.services.curriculum_service import curriculum_service
from backend.services.math_generation_service import MathGenerationService
from backend.services.geometry_render_service import GeometryRenderService
from curriculum.loader import get_chapter_by_official_code, CurriculumChapter  # Legacy - √† remplacer par MongoDB
from backend.services.curriculum_persistence_service import CurriculumPersistenceService
# P0 - SUPPRESSION IMPORTS LEGACY : GM07/GM08 g√©r√©s par pipeline normal
# from backend.services.gm07_handler import is_gm07_request, generate_gm07_exercise, generate_gm07_batch
# from backend.services.gm08_handler import is_gm08_request, generate_gm08_exercise, generate_gm08_batch
from backend.services.tests_dyn_handler import is_tests_dyn_request, generate_tests_dyn_exercise, generate_tests_dyn_batch, get_available_generators
from backend.generators.factory import GeneratorFactory  # P0.3 - Dispatch premium g√©n√©rique
from backend.services.template_renderer import render_template  # P0.3 - Rendu HTML templates
from backend.services.generator_template_service import get_template_service  # P1 - Templates DB
from backend.utils.difficulty_utils import (
    normalize_difficulty,
    coerce_to_supported_difficulty,
    map_ui_difficulty_to_generator,  # P4.D HOTFIX
)  # P4.B/P4.C - Normalisation et coercition difficult√©s
from logger import get_logger
from backend.observability import (
    get_request_context,
    get_logger as get_obs_logger,
    safe_random_choice,
    safe_randrange,
    ensure_request_id,
    set_request_context,
)

logger = get_logger()
obs_logger = get_obs_logger('PIPELINE')

router = APIRouter()

# ============================================================================
# P0 - HELPER PIPELINE SIMPLIFI√â : DYNAMIC ‚Üí STATIC fallback
# ============================================================================

async def generate_exercise_with_fallback(
    chapter_code: str,
    exercise_service,
    request: ExerciseGenerateRequest,
    ctx: dict,
    request_start: float,
    effective_grade: Optional[str] = None  # P0 - Grade effectif calcul√© (optionnel pour compatibilit√©)
) -> dict:
    """
    Pipeline simplifi√© P0 : Essaie DYNAMIC, fallback STATIC si √©chec.
    
    Returns:
        Exercice g√©n√©r√© (dynamique ou statique)
    
    Raises:
        HTTPException si aucun exercice disponible
    """
    from backend.services.tests_dyn_handler import format_dynamic_exercise
    
    # 1. Essayer DYNAMIC d'abord
    try:
        # P4.C - Coercer la difficult√© si un g√©n√©rateur dynamique est s√©lectionn√©
        requested_difficulty = request.difficulte if hasattr(request, 'difficulte') and request.difficulte else None
        
        # P0 - DIAGNOSTIC COMPLET pour 6E_G07
        logger.info(
            f"[DIAG_6E_G07] generate_exercise_with_fallback() appel√© avec "
            f"chapter_code={chapter_code}"
        )
        logger.info(
            f"[DIAG_6E_G07] Filtres: offer={request.offer if hasattr(request, 'offer') else None}, "
            f"difficulty={requested_difficulty}"
        )
        
        exercises = await exercise_service.get_exercises(
            chapter_code=chapter_code,
            offer=request.offer if hasattr(request, 'offer') else None,
            difficulty=requested_difficulty
        )
        
        # P0 - Logs de diagnostic pour comprendre pourquoi les exercices dynamiques ne sont pas trouv√©s
        logger.info(
            f"[DIAG_6E_G07] ========================================="
        )
        logger.info(
            f"[DIAG_6E_G07] Requ√™te MongoDB: collection='exercises', "
            f"query={{chapter_code: '{chapter_code.upper().replace('-', '_')}'"
        )
        if request.offer if hasattr(request, 'offer') else None:
            logger.info(
                f"[DIAG_6E_G07]   + offer: '{request.offer}'"
            )
        if requested_difficulty:
            logger.info(
                f"[DIAG_6E_G07]   + difficulty: '{requested_difficulty}'"
            )
        logger.info(
            f"[DIAG_6E_G07] }}"
        )
        logger.info(
            f"[DIAG_6E_G07] total_exercises={len(exercises)}"
        )
        
        # Log d√©taill√© de chaque exercice pour diagnostic
        for idx, ex in enumerate(exercises):
            logger.info(
                f"[DIAG_6E_G07] exercise[{idx}]: id={ex.get('id')} "
                f"is_dynamic={ex.get('is_dynamic')} (type: {type(ex.get('is_dynamic'))}) "
                f"generator_key={ex.get('generator_key')} "
                f"offer={ex.get('offer')} "
                f"difficulty={ex.get('difficulty')} "
                f"enonce_preview={str(ex.get('enonce_html', ''))[:50]}..."
            )
        
        dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
        static_exercises = [ex for ex in exercises if ex.get("is_dynamic") is not True]
        
        logger.info(
            f"[PIPELINE_DEBUG] generate_exercise_with_fallback() - R√©sultats:"
        )
        logger.info(
            f"[PIPELINE_DEBUG]   total_exercises={len(exercises)}"
        )
        logger.info(
            f"[PIPELINE_DEBUG]   dynamic_count={len(dynamic_exercises)}"
        )
        logger.info(
            f"[PIPELINE_DEBUG]   static_count={len(static_exercises)}"
        )
        
        # P4.D - Filtrer selon enabled_generators si disponible (pass√© via ctx)
        enabled_generators_raw = ctx.get("enabled_generators", [])
        dynamic_count_before_filter = len(dynamic_exercises)
        
        # P0 - FIX : Normaliser enabled_generators (peut √™tre List[str] ou List[dict])
        enabled_generators_for_chapter = normalize_enabled_generators(enabled_generators_raw)
        
        logger.info(
            f"[PIPELINE_DEBUG]   enabled_generators_raw_type={type(enabled_generators_raw).__name__}"
        )
        logger.info(
            f"[PIPELINE_DEBUG]   enabled_generators_raw={enabled_generators_raw}"
        )
        logger.info(
            f"[PIPELINE_DEBUG]   enabled_generator_keys (normalis√©s)={enabled_generators_for_chapter}"
        )
        
        if enabled_generators_for_chapter:
            logger.info(
                f"[PIPELINE_DEBUG]   Filtrant selon enabled_generators={enabled_generators_for_chapter} "
                f"(avant filtre: {dynamic_count_before_filter} exercices dynamiques)"
            )
            dynamic_exercises = [
                ex for ex in dynamic_exercises
                if ex.get("generator_key") and ex.get("generator_key").upper() in enabled_generators_for_chapter
            ]
            logger.info(
                f"[PIPELINE_DEBUG]   dynamic_after_enabled_generators={len(dynamic_exercises)}"
            )
            logger.info(
                f"[PROF_GENERATORS] generate_exercise_with_fallback: Filtr√© {len(dynamic_exercises)} exercices "
                f"selon enabled_generators={enabled_generators_for_chapter}"
            )
        else:
            logger.info(
                f"[PIPELINE_DEBUG]   Aucun enabled_generators dans ctx (ou normalisation vide), "
                f"utilisant tous les {len(dynamic_exercises)} exercices dynamiques disponibles"
            )
        
        if len(dynamic_exercises) > 0:
            selected_exercise = safe_random_choice(dynamic_exercises, ctx, obs_logger)
            
            # P0 - Appliquer map_ui_difficulty_to_generator() pour les g√©n√©rateurs dynamiques
            generator_key = selected_exercise.get("generator_key")
            coerced_difficulty = requested_difficulty
            if generator_key and requested_difficulty:
                # P0 - Utiliser map_ui_difficulty_to_generator() au lieu de coerce_to_supported_difficulty()
                coerced_difficulty = map_ui_difficulty_to_generator(
                    generator_key,
                    requested_difficulty,
                    logger
                )
                
                # Mettre √† jour la difficult√© dans le contexte pour les logs
                ctx['requested_difficulty'] = requested_difficulty
                ctx['coerced_difficulty'] = coerced_difficulty
                ctx['generator_key'] = generator_key
                
                if coerced_difficulty != requested_difficulty:
                    logger.info(
                        f"[DIFFICULTY_MAPPED] generate_exercise_with_fallback: "
                        f"generator={generator_key} ui={requested_difficulty} -> effective={coerced_difficulty}"
                    )
            
            timestamp = int(time.time() * 1000)
            dyn_exercise = format_dynamic_exercise(
                exercise_template=selected_exercise,
                timestamp=timestamp,
                seed=request.seed if hasattr(request, 'seed') and request.seed else None
            )
            
            # P0 - Ajouter ui_params et effective_params dans metadata
            if 'metadata' not in dyn_exercise:
                dyn_exercise['metadata'] = {}
            
            # Construire ui_params si pas d√©j√† fait
            if 'ui_params' not in dyn_exercise['metadata']:
                ui_params_fallback = {}
                if hasattr(request, 'difficulte') and request.difficulte:
                    ui_params_fallback['difficulty_ui'] = request.difficulte
                if hasattr(request, 'exercise_type') and request.exercise_type:
                    ui_params_fallback['exercise_type_ui'] = request.exercise_type
                if hasattr(request, 'seed') and request.seed:
                    ui_params_fallback['seed'] = request.seed
                dyn_exercise['metadata']['ui_params'] = ui_params_fallback
            
            # Construire effective_params
            effective_params_fallback = {
                'difficulty_effective': coerced_difficulty if 'coerced_difficulty' in locals() else requested_difficulty,
                'grade_effective': effective_grade if effective_grade else (request.niveau if hasattr(request, 'niveau') else "6e"),
                'seed': request.seed if hasattr(request, 'seed') and request.seed else None
            }
            if hasattr(request, 'exercise_type') and request.exercise_type:
                effective_params_fallback['exercise_type_effective'] = request.exercise_type
            dyn_exercise['metadata']['effective_params'] = effective_params_fallback
            
            # P0 - Logs avec param√®tres
            logger.info(
                f"[GENERATOR_OK] ‚úÖ Exercice DYNAMIQUE g√©n√©r√©: "
                f"chapter={chapter_code}, id={selected_exercise.get('id')}, "
                f"generator={selected_exercise.get('generator_key')}, "
                f"ui_params={dyn_exercise['metadata'].get('ui_params')}, "
                f"effective_params={dyn_exercise['metadata'].get('effective_params')}"
            )
            
            duration_ms = int((time.time() - request_start) * 1000)
            # P0 - FIX : Retirer generator_key de ctx avant de le passer explicitement
            # pour √©viter "got multiple values for keyword argument 'generator_key'"
            ctx_for_log = {k: v for k, v in ctx.items() if k != 'generator_key'}
            
            # P0 - S√âCURIT√â : Rendre l'observabilit√© non-bloquante
            try:
                obs_logger.info(
                    "event=dynamic_generated",
                    event="dynamic_generated",
                    outcome="success",
                    duration_ms=duration_ms,
                    exercise_id=selected_exercise.get('id'),
                    generator_key=selected_exercise.get('generator_key'),
                    **ctx_for_log
                )
            except Exception as log_error:
                logger.exception(
                    f"[OBSERVABILITY_FAIL] Erreur lors du log observability pour exercice dynamique: {log_error}"
                )
                # Continuer la g√©n√©ration m√™me si le log √©choue
            
            return dyn_exercise
    
    except Exception as e:
        logger.warning(
            f"[GENERATOR_FAIL] ‚ùå Erreur g√©n√©ration DYNAMIC pour {chapter_code}: {e}. "
            f"Fallback STATIC activ√©."
        )
        logger.warning(
            f"[FALLBACK_DEBUG] Exception d√©tails: type={type(e).__name__}, "
            f"message={str(e)}"
        )
        # P0 - S√âCURIT√â : Rendre l'observabilit√© non-bloquante
        try:
            obs_logger.warning(
                "event=dynamic_failed",
                event="dynamic_failed",
                outcome="fallback",
                reason="exception",
                exception_type=type(e).__name__,
                **ctx
            )
        except Exception as log_error:
            logger.exception(
                f"[OBSERVABILITY_FAIL] Erreur lors du log observability pour dynamic_failed: {log_error}"
            )
            # Continuer m√™me si le log √©choue
    
    # 2. Fallback STATIC
    try:
        logger.info(
            f"[FALLBACK_DEBUG] Tentative fallback STATIC pour {chapter_code} "
            f"(aucun exercice dynamique trouv√© ou erreur)"
        )
        exercises = await exercise_service.get_exercises(
            chapter_code=chapter_code,
            offer=request.offer if hasattr(request, 'offer') else None,
            difficulty=request.difficulte if hasattr(request, 'difficulte') else None
        )
        static_exercises = [ex for ex in exercises if ex.get("is_dynamic") is not True]
        
        logger.info(
            f"[FALLBACK_DEBUG] static_exercises_count={len(static_exercises)} "
            f"pour chapter_code={chapter_code}"
        )
        
        if len(static_exercises) > 0:
            selected_static = safe_random_choice(static_exercises, ctx, obs_logger)
            
            logger.warning(
                f"[FALLBACK_STATIC] ‚ö†Ô∏è Utilisation d'un exercice STATIC pour {chapter_code}: "
                f"id={selected_static.get('id')}, "
                f"enonce_preview={selected_static.get('enonce_html', '')[:100]}..."
            )
            
            timestamp = int(time.time() * 1000)
            
            # R√©cup√©rer le chapitre pour les m√©tadonn√©es
            curriculum_chapter = get_chapter_by_official_code(chapter_code)
            
            static_exercise = {
                "id_exercice": f"static_{chapter_code}_{selected_static.get('id')}_{timestamp}",
                "niveau": curriculum_chapter.niveau if curriculum_chapter else "6e",
                "chapitre": curriculum_chapter.libelle if curriculum_chapter else chapter_code,
                "enonce_html": selected_static.get("enonce_html") or "",
                "solution_html": selected_static.get("solution_html") or "",
                "needs_svg": selected_static.get("needs_svg") or False,
                "exercise_type": selected_static.get("exercise_type"),
                "pdf_token": f"static_{chapter_code}_{selected_static.get('id')}_{timestamp}",
                "metadata": {
                    "offer": selected_static.get("offer"),
                    "difficulty": selected_static.get("difficulty"),
                    "source": "admin_exercises_static",
                    "is_fallback": True,
                    "fallback_reason": "dynamic_unavailable"
                }
            }
            
            duration_ms = int((time.time() - request_start) * 1000)
            obs_logger.info(
                "event=static_fallback_used",
                event="static_fallback_used",
                outcome="success",
                duration_ms=duration_ms,
                exercise_id=selected_static.get('id'),
                **ctx
            )
            logger.info(
                f"[GENERATOR_OK] ‚úÖ Exercice STATIQUE (fallback): "
                f"chapter={chapter_code}, id={selected_static.get('id')}"
            )
            return static_exercise
    
    except Exception as e:
        logger.error(
            f"[GENERATOR_FAIL] ‚ùå Erreur fallback STATIC pour {chapter_code}: {e}. "
            f"Aucun exercice disponible."
        )
        obs_logger.error(
            "event=static_fallback_failed",
            event="static_fallback_failed",
            outcome="error",
            exception_type=type(e).__name__,
            **ctx
        )
    
    # 3. Aucun exercice disponible
    raise HTTPException(
        status_code=422,
        detail={
            "error_code": "NO_EXERCISE_AVAILABLE",
            "error": "no_exercise_available",
            "message": f"Aucun exercice disponible pour le chapitre '{chapter_code}' avec les crit√®res demand√©s.",
            "chapter_code": chapter_code,
            "hint": "V√©rifiez que des exercices existent en DB pour ce chapitre."
        }
    )

# ============================================================================
# INSTANCES GLOBALES DES SERVICES (V1-BE-002-FIX: Performance)
# Instanciation unique pour √©viter de recr√©er les services √† chaque requ√™te
# ============================================================================

_math_service = MathGenerationService()
_geom_service = GeometryRenderService()


# ============================================================================
# MOD√àLES POUR L'ENDPOINT BATCH GM07
# ============================================================================

class GM07BatchRequest(BaseModel):
    """Request model pour le batch GM07"""
    code_officiel: str = Field(default="6e_GM07", description="Code officiel (doit √™tre 6e_GM07)")
    difficulte: Optional[str] = Field(default=None, description="facile, moyen, difficile")
    offer: Optional[str] = Field(default="free", description="free ou pro")
    nb_exercices: int = Field(default=1, ge=1, le=20, description="Nombre d'exercices (1-20)")
    seed: Optional[int] = Field(default=None, description="Seed pour reproductibilit√©")


class GM07BatchResponse(BaseModel):
    """Response model pour le batch GM07"""
    exercises: List[dict] = Field(description="Liste des exercices g√©n√©r√©s")
    batch_metadata: dict = Field(description="M√©tadonn√©es du batch")


# ============================================================================
# MOD√àLES POUR L'ENDPOINT BATCH GM08
# ============================================================================

class GM08BatchRequest(BaseModel):
    """Request model pour le batch GM08"""
    code_officiel: str = Field(default="6e_GM08", description="Code officiel (doit √™tre 6e_GM08)")
    difficulte: Optional[str] = Field(default=None, description="facile, moyen, difficile")
    offer: Optional[str] = Field(default="free", description="free ou pro")
    nb_exercices: int = Field(default=1, ge=1, le=20, description="Nombre d'exercices (1-20)")
    seed: Optional[int] = Field(default=None, description="Seed pour reproductibilit√©")


class GM08BatchResponse(BaseModel):
    """Response model pour le batch GM08"""
    exercises: List[dict] = Field(description="Liste des exercices g√©n√©r√©s")
    batch_metadata: dict = Field(description="M√©tadonn√©es du batch")


# ============================================================================
# MOD√àLES POUR L'ENDPOINT BATCH TESTS_DYN (Exercices Dynamiques)
# ============================================================================

class TestsDynBatchRequest(BaseModel):
    """Request model pour le batch TESTS_DYN (dynamique)"""
    code_officiel: str = Field(default="6e_TESTS_DYN", description="Code officiel")
    difficulte: Optional[str] = Field(default=None, description="facile, moyen, difficile")
    offer: Optional[str] = Field(default="free", description="free ou pro")
    nb_exercices: int = Field(default=1, ge=1, le=20, description="Nombre d'exercices (1-20)")
    seed: Optional[int] = Field(default=None, description="Seed pour reproductibilit√©")


class TestsDynBatchResponse(BaseModel):
    """Response model pour le batch TESTS_DYN"""
    exercises: List[dict] = Field(description="Liste des exercices g√©n√©r√©s dynamiquement")
    batch_metadata: dict = Field(description="M√©tadonn√©es du batch")


# ============================================================================
# ENDPOINTS BATCH D√âDI√âS GM07 / GM08 / TESTS_DYN
# ============================================================================

@router.post("/generate/batch/tests_dyn", response_model=TestsDynBatchResponse, tags=["Dynamic"])
async def generate_tests_dyn_batch_endpoint(request: TestsDynBatchRequest):
    """
    G√©n√®re un lot d'exercices DYNAMIQUES (templates + g√©n√©rateur THALES_V1).
    
    **Comportement:**
    - Les exercices sont g√©n√©r√©s √† la vol√©e avec des valeurs diff√©rentes
    - Chaque appel avec un seed diff√©rent produit des exercices diff√©rents
    - Le m√™me seed reproduit exactement les m√™mes exercices
    
    **G√©n√©rateur THALES_V1:**
    - Agrandissements et r√©ductions de figures g√©om√©triques
    - Variables: coefficient, dimensions initiales/finales
    - SVG g√©n√©r√©s dynamiquement pour chaque exercice
    """
    logger.info(f"üé≤ TESTS_DYN Batch Request: offer={request.offer}, difficulty={request.difficulte}, count={request.nb_exercices}, seed={request.seed}")
    
    # G√©n√©rer le batch dynamique
    exercises, batch_meta = generate_tests_dyn_batch(
        offer=request.offer,
        difficulty=request.difficulte,
        count=request.nb_exercices,
        seed=request.seed
    )
    
    if not exercises:
        raise HTTPException(
            status_code=422,
            detail={
                "error": "no_exercises_found",
                "message": "Aucun exercice disponible pour les filtres s√©lectionn√©s.",
                "batch_metadata": batch_meta
            }
        )
    
    logger.info(f"‚úÖ TESTS_DYN Batch generated: {len(exercises)} dynamic exercises")
    
    return TestsDynBatchResponse(
        exercises=exercises,
        batch_metadata=batch_meta
    )


@router.get("/generators", tags=["Dynamic"])
async def list_available_generators():
    """
    Liste les g√©n√©rateurs dynamiques disponibles.
    
    **G√©n√©rateurs actuels:**
    - THALES_V1: Agrandissements/r√©ductions de figures (6e)
    """
    generators = get_available_generators()
    return {
        "generators": generators,
        "count": len(generators),
        "details": {
            "THALES_V1": {
                "name": "Agrandissements et R√©ductions",
                "niveau": "6e",
                "description": "G√©n√®re des exercices sur les transformations de figures g√©om√©triques",
                "figure_types": ["carre", "rectangle", "triangle"],
                "difficulties": ["facile", "moyen", "difficile"]
            }
        }
    }


@router.post("/generate/batch/gm07", response_model=GM07BatchResponse, tags=["GM07"])
async def generate_gm07_batch_endpoint(request: GM07BatchRequest):
    """
    G√©n√®re un lot d'exercices GM07 SANS DOUBLONS.
    
    **Comportement produit:**
    - Si pool_size >= N: retourne exactement N exercices UNIQUES
    - Si pool_size < N: retourne pool_size exercices avec metadata.warning
    - JAMAIS de doublons
    
    **Exemple de r√©ponse:**
    ```json
    {
        "exercises": [...],
        "batch_metadata": {
            "requested": 5,
            "returned": 4,
            "available": 4,
            "warning": "Seulement 4 exercices disponibles pour difficult√© 'facile' et offre 'free'."
        }
    }
    ```
    """
    # V√©rifier que c'est bien GM07
    if request.code_officiel.upper() != "6E_GM07":
        raise HTTPException(
            status_code=400,
            detail={
                "error": "invalid_chapter",
                "message": "Cet endpoint est r√©serv√© au chapitre GM07",
                "hint": "Utilisez code_officiel='6e_GM07'"
            }
        )
    
    logger.info(f"üéØ GM07 Batch Request: offer={request.offer}, difficulty={request.difficulte}, count={request.nb_exercices}")
    
    # G√©n√©rer le batch
    exercises, batch_meta = generate_gm07_batch(
        offer=request.offer,
        difficulty=request.difficulte,
        count=request.nb_exercices,
        seed=request.seed
    )
    
    if not exercises:
        raise HTTPException(
            status_code=422,
            detail={
                "error": "no_exercises_found",
                "message": batch_meta.get("warning", "Aucun exercice disponible"),
                "batch_metadata": batch_meta
            }
        )
    
    # Log le r√©sultat
    warning = batch_meta.get("warning", "")
    logger.info(f"‚úÖ GM07 Batch generated: {len(exercises)} exercises. {warning}")
    
    return GM07BatchResponse(
        exercises=exercises,
        batch_metadata=batch_meta
    )


@router.post("/generate/batch/gm08", response_model=GM08BatchResponse, tags=["GM08"])
async def generate_gm08_batch_endpoint(request: GM08BatchRequest):
    """
    G√©n√®re un lot d'exercices GM08 SANS DOUBLONS.
    
    **Th√®me:** Grandeurs et Mesures - Longueurs, P√©rim√®tres
    
    **Comportement produit:**
    - Si pool_size >= N: retourne exactement N exercices UNIQUES
    - Si pool_size < N: retourne pool_size exercices avec metadata.warning
    - JAMAIS de doublons
    
    **Exemple de r√©ponse:**
    ```json
    {
        "exercises": [...],
        "batch_metadata": {
            "requested": 5,
            "returned": 4,
            "available": 4,
            "warning": "Seulement 4 exercices disponibles pour difficult√© 'facile' et offre 'free'."
        }
    }
    ```
    """
    # V√©rifier que c'est bien GM08
    if request.code_officiel.upper() != "6E_GM08":
        raise HTTPException(
            status_code=400,
            detail={
                "error": "invalid_chapter",
                "message": "Cet endpoint est r√©serv√© au chapitre GM08",
                "hint": "Utilisez code_officiel='6e_GM08'"
            }
        )
    
    logger.info(f"üéØ GM08 Batch Request: offer={request.offer}, difficulty={request.difficulte}, count={request.nb_exercices}")
    
    # G√©n√©rer le batch
    exercises, batch_meta = generate_gm08_batch(
        offer=request.offer,
        difficulty=request.difficulte,
        count=request.nb_exercices,
        seed=request.seed
    )
    
    if not exercises:
        raise HTTPException(
            status_code=422,
            detail={
                "error": "no_exercises_found",
                "message": batch_meta.get("warning", "Aucun exercice disponible"),
                "batch_metadata": batch_meta
            }
        )
    
    # Log le r√©sultat
    warning = batch_meta.get("warning", "")
    logger.info(f"‚úÖ GM08 Batch generated: {len(exercises)} exercises. {warning}")
    
    return GM08BatchResponse(
        exercises=exercises,
        batch_metadata=batch_meta
    )


def normalize_enabled_generators(raw: Any) -> List[str]:
    """
    Normalise enabled_generators depuis diff√©rents formats possibles.
    
    Formats support√©s:
    - List[str]: ["CALCUL_NOMBRES_V1", "SYMETRIE_AXIALE_V2"]
    - List[dict]: [{"generator_key": "CALCUL_NOMBRES_V1", "is_enabled": True, ...}, ...]
    - None ou autre: []
    
    Returns:
        Liste de generator_key (strings) normalis√©s
    """
    if not raw:
        return []
    
    if isinstance(raw, list):
        if len(raw) == 0:
            return []
        
        # Cas 1: List[str]
        if isinstance(raw[0], str):
            return [g.upper() for g in raw if g]
        
        # Cas 2: List[dict]
        if isinstance(raw[0], dict):
            return [
                d["generator_key"].upper()
                for d in raw
                if isinstance(d, dict) and d.get("is_enabled") and d.get("generator_key")
            ]
    
    return []


def generate_exercise_id(niveau: str, chapitre: str) -> str:
    """
    G√©n√®re un identifiant unique pour l'exercice
    
    Format: ex_{niveau}_{chapitre_slug}_{timestamp}
    Exemple: ex_5e_symetrie-axiale_1702401234
    
    Args:
        niveau: Niveau scolaire
        chapitre: Nom du chapitre
    
    Returns:
        Identifiant unique
    """
    # Convertir le chapitre en slug (minuscules, tirets)
    chapitre_slug = re.sub(r'[^a-z0-9]+', '-', chapitre.lower()).strip('-')
    
    # Timestamp pour unicit√©
    timestamp = int(time.time())
    
    return f"ex_{niveau}_{chapitre_slug}_{timestamp}"


def build_enonce_html(enonce: str, svg: Optional[str] = None) -> str:
    """
    Construit l'√©nonc√© HTML √† partir de l'√©nonc√© texte et du SVG
    
    NOTE: L'√©nonc√© n'est PAS √©chapp√© car il peut contenir du HTML valide
    (tableaux de proportionnalit√©, etc.) g√©n√©r√© par notre code interne.
    
    Args:
        enonce: √ânonc√© textuel (peut contenir du HTML de tableaux, etc.)
        svg: SVG optionnel (non √©chapp√© car g√©n√©r√© par notre code interne)
    
    Returns:
        HTML de l'√©nonc√©
    """
    # NOTE: On n'√©chappe PAS l'√©nonc√© car il peut contenir du HTML valide
    # (tableaux, formules, etc.) g√©n√©r√© par notre propre code backend.
    # Ce HTML est de confiance car il provient de math_generation_service.py
    
    html = f"<div class='exercise-enonce'><p>{enonce}</p>"
    
    # Le SVG n'est PAS √©chapp√© car il est g√©n√©r√© par notre code interne de confiance
    if svg:
        html += f"<div class='exercise-figure'>{svg}</div>"
    
    html += "</div>"
    
    return html


def build_solution_html(etapes: list, resultat_final: str, svg_correction: Optional[str] = None) -> str:
    """
    Construit la solution HTML √† partir des √©tapes et du r√©sultat
    
    NOTE: Les √©tapes et le r√©sultat ne sont PAS √©chapp√©s car ils peuvent
    contenir des formules LaTeX ou du HTML g√©n√©r√© par notre code interne.
    
    Args:
        etapes: Liste des √©tapes de r√©solution (peuvent contenir LaTeX/HTML)
        resultat_final: R√©sultat final (peut contenir LaTeX/HTML)
        svg_correction: SVG de correction optionnel (non √©chapp√© car g√©n√©r√© par notre code interne)
    
    Returns:
        HTML de la solution
    """
    html = "<div class='exercise-solution'>"
    html += "<p><strong>Solution :</strong></p>"
    
    if etapes:
        html += "<ol>"
        for etape in etapes:
            # NOTE: On n'√©chappe PAS les √©tapes car elles peuvent contenir
            # des formules LaTeX (\\frac{}{}) ou du HTML de confiance
            html += f"<li>{etape}</li>"
        html += "</ol>"
    
    # NOTE: On n'√©chappe PAS le r√©sultat car il peut contenir du LaTeX
    html += f"<p><strong>R√©sultat final :</strong> {resultat_final}</p>"
    
    # Le SVG n'est PAS √©chapp√© car il est g√©n√©r√© par notre code interne de confiance
    if svg_correction:
        html += f"<div class='exercise-figure-correction'>{svg_correction}</div>"
    
    html += "</div>"
    
    return html


def _build_fallback_enonce(spec, chapitre: str) -> str:
    """
    G√©n√®re un √©nonc√© p√©dagogique de fallback bas√© sur les param√®tres de l'exercice
    
    Args:
        spec: Sp√©cification de l'exercice (MathExerciseSpec)
        chapitre: Nom du chapitre
    
    Returns:
        √ânonc√© lisible pour l'√©l√®ve
    """
    params = spec.parametres or {}
    
    # 1. Si expression math√©matique pr√©sente, l'utiliser
    expression = params.get("expression", "")
    if expression:
        return f"Calculer : {expression}"
    
    # 2. Fallback sp√©cifique par type d'exercice
    type_exercice = str(spec.type_exercice).lower() if spec.type_exercice else ""
    
    # Fractions
    if "fractions" in chapitre.lower() or "fraction" in type_exercice:
        frac1 = params.get("fraction1", "")
        frac2 = params.get("fraction2", "")
        operation = params.get("operation", "+")
        if frac1 and frac2:
            op_text = "la somme" if operation == "+" else "la diff√©rence"
            return f"Calculer {op_text} des fractions {frac1} et {frac2}. Donner le r√©sultat sous forme de fraction irr√©ductible."
    
    # √âquations
    if "equation" in type_exercice or "√©quation" in chapitre.lower():
        equation = params.get("equation", "")
        if equation:
            return f"R√©soudre l'√©quation suivante : {equation}"
    
    # Calculs d√©cimaux
    if "decimaux" in type_exercice or "d√©cimaux" in chapitre.lower():
        a = params.get("a", "")
        b = params.get("b", "")
        if a and b:
            return f"Effectuer le calcul suivant : {a} et {b}"
    
    # G√©om√©trie - triangles
    if "triangle" in type_exercice or "triangle" in chapitre.lower():
        if params.get("points"):
            return f"Soit le triangle {params.get('points', 'ABC')}. Calculer les mesures demand√©es."
    
    # P√©rim√®tre/Aire
    if "perimetre" in type_exercice or "aire" in type_exercice:
        figure = params.get("figure", params.get("type_figure", "figure"))
        return f"Calculer le p√©rim√®tre et/ou l'aire de la {figure} donn√©e."
    
    # Volume - CORRIG√â P0-001: Toujours inclure les dimensions dans l'√©nonc√©
    if "volume" in type_exercice:
        solide = params.get("solide", params.get("type_solide", "solide"))
        
        # Cube : inclure l'ar√™te
        if solide == "cube":
            arete = params.get("arete", params.get("cote", ""))
            if arete:
                return f"Calculer le volume d'un cube d'ar√™te {arete} cm."
        
        # Pav√© droit : inclure les 3 dimensions
        elif solide == "pave" or solide == "pav√©" or solide == "pave_droit":
            longueur = params.get("longueur", params.get("L", ""))
            largeur = params.get("largeur", params.get("l", ""))
            hauteur = params.get("hauteur", params.get("h", ""))
            if longueur and largeur and hauteur:
                return f"Calculer le volume d'un pav√© droit de dimensions {longueur} cm √ó {largeur} cm √ó {hauteur} cm."
        
        # Cylindre : inclure rayon et hauteur
        elif solide == "cylindre":
            rayon = params.get("rayon", params.get("r", ""))
            hauteur = params.get("hauteur", params.get("h", ""))
            if rayon and hauteur:
                return f"Calculer le volume d'un cylindre de rayon {rayon} cm et de hauteur {hauteur} cm."
        
        # Prisme : inclure base et hauteur
        elif solide == "prisme":
            base_longueur = params.get("base_longueur", "")
            base_largeur = params.get("base_largeur", "")
            hauteur = params.get("hauteur", "")
            if base_longueur and base_largeur and hauteur:
                return f"Calculer le volume d'un prisme droit √† base rectangulaire de dimensions {base_longueur} cm √ó {base_largeur} cm et de hauteur {hauteur} cm."
            elif hauteur:
                aire_base = params.get("aire_base", "")
                if aire_base:
                    return f"Calculer le volume d'un prisme d'aire de base {aire_base} cm¬≤ et de hauteur {hauteur} cm."
        
        # Fallback avec dimensions si disponibles
        dimensions = []
        for key, label in [("longueur", "L"), ("largeur", "l"), ("hauteur", "h"), 
                           ("arete", "ar√™te"), ("rayon", "r"), ("base_longueur", "base L"),
                           ("base_largeur", "base l")]:
            if key in params and params[key]:
                dimensions.append(f"{label}={params[key]} cm")
        
        if dimensions:
            dims_str = ", ".join(dimensions)
            return f"Calculer le volume du {solide} ({dims_str})."
        
        return f"Calculer le volume du {solide}."
    
    # Probabilit√©s
    if "probabilite" in type_exercice:
        return "Calculer la probabilit√© demand√©e."
    
    # Statistiques
    if "statistique" in type_exercice:
        return "Analyser les donn√©es statistiques ci-dessous et r√©pondre aux questions."
    
    # 3. Fallback g√©n√©rique am√©lior√©
    # Essayer de construire quelque chose d'utile avec les param√®tres disponibles
    if params:
        # Chercher des indices dans les cl√©s des param√®tres
        param_keys = list(params.keys())
        if any("nombre" in k.lower() for k in param_keys):
            return "Effectuer les calculs demand√©s sur les nombres suivants."
        if any("point" in k.lower() for k in param_keys):
            return "R√©aliser la construction g√©om√©trique demand√©e."
    
    # 4. Dernier recours : message g√©n√©rique mais informatif
    return f"Exercice de {chapitre}. R√©pondre aux questions ci-dessous."


@router.post(
    "/generate",
    response_model=ExerciseGenerateResponse,
    responses={
        422: {
            "model": ErrorDetail,
            "description": "Niveau, chapitre ou code_officiel invalide"
        },
        500: {
            "description": "Erreur lors de la g√©n√©ration de l'exercice"
        }
    },
    summary="G√©n√©rer un exercice math√©matique",
    description="""
    G√©n√®re un exercice personnalis√© avec √©nonc√©, figure g√©om√©trique et solution.
    
    **Deux modes de fonctionnement :**
    
    1. **Mode legacy** : Utiliser `niveau` + `chapitre`
       ```json
       {"niveau": "6e", "chapitre": "Fractions", "difficulte": "moyen"}
       ```
    
    2. **Mode officiel** : Utiliser `code_officiel` (r√©f√©rentiel 6e)
       ```json
       {"code_officiel": "6e_N08", "difficulte": "moyen"}
       ```
    
    Si `code_officiel` est fourni, il a priorit√© sur `chapitre`.
    """
)
async def generate_exercise(request: ExerciseGenerateRequest):
    """
    G√©n√®re un exercice math√©matique complet.
    
    Args:
        request: Requ√™te avec niveau/chapitre (legacy) ou code_officiel (nouveau)
    
    Returns:
        Exercice g√©n√©r√© avec √©nonc√© HTML, SVG, solution et pdf_token
    """
    request_start = time.time()
    ensure_request_id()
    
    # P0 - Construire ui_params (param√®tres UI bruts)
    ui_params = request.ui_params or {}
    if hasattr(request, 'difficulte') and request.difficulte:
        ui_params['difficulty_ui'] = request.difficulte
    if hasattr(request, 'exercise_type') and request.exercise_type:
        ui_params['exercise_type_ui'] = request.exercise_type
    if hasattr(request, 'grade') and request.grade:
        ui_params['grade_ui'] = request.grade
    if hasattr(request, 'seed') and request.seed:
        ui_params['seed'] = request.seed
    
    # P0 - Calculer grade avec priorit√© : payload.grade -> contexte grade -> extraction code_officiel -> fallback
    effective_grade = None
    if hasattr(request, 'grade') and request.grade:
        effective_grade = request.grade
    elif request.code_officiel:
        # Extraire grade depuis code_officiel (format: "6e_N04")
        parts = request.code_officiel.split('_', 1)
        if len(parts) == 2 and parts[0] in ['6e', '5e', '4e', '3e']:
            effective_grade = parts[0]
    elif hasattr(request, 'niveau') and request.niveau:
        effective_grade = request.niveau
    else:
        effective_grade = "6e"  # Fallback
    
    # P4.B - Normaliser la difficult√© (standard -> moyen)
    normalized_difficulty = None
    if hasattr(request, 'difficulte') and request.difficulte:
        try:
            normalized_difficulty = normalize_difficulty(request.difficulte)
            # Mettre √† jour la requ√™te avec la difficult√© normalis√©e
            request.difficulte = normalized_difficulty
        except ValueError as e:
            logger.warning(f"Difficult√© invalide '{request.difficulte}', utilisation de 'moyen' par d√©faut: {e}")
            normalized_difficulty = "moyen"
            request.difficulte = normalized_difficulty
    
    set_request_context(
        chapter_code=getattr(request, 'code_officiel', None),
        niveau=getattr(request, 'niveau', None),
        chapitre=getattr(request, 'chapitre', None),
        difficulty=normalized_difficulty or getattr(request, 'difficulte', None),
        offer=getattr(request, 'offer', None),
        seed=getattr(request, 'seed', None),
    )
    obs_logger.info(
        "event=request_in",
        event="request_in",
        outcome="in_progress",
        chapter_code=getattr(request, 'code_officiel', None),
        niveau=getattr(request, 'niveau', None),
        difficulty=getattr(request, 'difficulte', None),
        offer=getattr(request, 'offer', None),
    )
    
    # ============================================================================
    # P0 - SUPPRESSION INTERCEPTS LEGACY GM07/GM08
    # ============================================================================
    # Les exercices GM07/GM08 sont maintenant en DB (migration P3.2).
    # Ils sont g√©r√©s par le pipeline normal (DYNAMIC ‚Üí STATIC fallback).
    # Plus besoin d'intercepts hardcod√©s.
    # ============================================================================
    
    # ============================================================================
    # TESTS_DYN INTERCEPT: Chapitre de test pour exercices dynamiques
    # ============================================================================
    
    if is_tests_dyn_request(request.code_officiel):
        nb = request.nb_exercices if hasattr(request, 'nb_exercices') else 1
        logger.info(f"üé≤ TESTS_DYN Request intercepted: offer={request.offer}, difficulty={request.difficulte}, count={nb}")
        
        # Si on demande 1 seul exercice
        if nb == 1:
            dyn_exercise = generate_tests_dyn_exercise(
                offer=request.offer,
                difficulty=request.difficulte,
                seed=request.seed
            )
            
            if not dyn_exercise:
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "NO_EXERCISE_AVAILABLE",
                        "error": "no_tests_dyn_exercise_found",
                        "message": f"Aucun exercice disponible pour offer='{request.offer}' et difficulty='{request.difficulte}'. Le fallback vers 'free' a √©t√© tent√© mais aucun exercice n'a √©t√© trouv√©.",
                        "hint": "V√©rifiez les filtres (difficulty) ou utilisez /generate/batch/tests_dyn pour les lots"
                    }
                )
            
            logger.info(f"‚úÖ TESTS_DYN Exercise generated: id={dyn_exercise['id_exercice']}, "
                       f"generator={dyn_exercise['metadata'].get('generator_key')}")
            
            return dyn_exercise
        
        # Si on demande plusieurs exercices via cet endpoint
        exercises, batch_meta = generate_tests_dyn_batch(
            offer=request.offer,
            difficulty=request.difficulte,
            count=nb,
            seed=request.seed
        )
        
        if not exercises:
            raise HTTPException(
                status_code=422,
                detail={
                    "error": "no_tests_dyn_exercise_found",
                    "message": "Aucun exercice dynamique trouv√©",
                    "hint": "Utilisez /generate/batch/tests_dyn pour les lots"
                }
            )
        
        logger.info(f"‚úÖ TESTS_DYN Batch via /generate: {len(exercises)} exercises")
        
        return exercises[0]
    
    # ============================================================================
    # 0. R√âSOLUTION DU MODE (code_officiel vs legacy) - Pour autres chapitres
    # ============================================================================
    
    curriculum_chapter: Optional[CurriculumChapter] = None
    exercise_types_override: Optional[List[MathExerciseType]] = None
    filtered_premium_generators: List[str] = []  # P2.1 - Track des g√©n√©rateurs premium exclus
    
    # P4.D - Charger le chapitre depuis MongoDB (source de v√©rit√© unique)
    chapter_from_db: Optional[Dict[str, Any]] = None
    enabled_generators_list: List[Dict[str, Any]] = []
    
    if request.code_officiel:
        # Mode code_officiel : chercher dans MongoDB
        from server import db
        curriculum_service_db = CurriculumPersistenceService(db)
        await curriculum_service_db.initialize()
        
        # P0 - FIX : Normaliser le code_officiel AVANT la lecture DB
        # Le chapitre en DB peut √™tre stock√© en uppercase ("6E_G07") alors que
        # la requ√™te arrive en mixed case ("6e_G07")
        normalized_code_officiel = request.code_officiel.upper().replace("-", "_")
        
        logger.info(
            f"[DIAG_6E_G07] Normalisation code_officiel: "
            f"requested='{request.code_officiel}' ‚Üí normalized='{normalized_code_officiel}'"
        )
        
        chapter_from_db = await curriculum_service_db.get_chapter_by_code(normalized_code_officiel)
        
        if not chapter_from_db:
            # Fallback legacy : chercher dans le fichier JSON (pour compatibilit√©)
            curriculum_chapter = get_chapter_by_official_code(request.code_officiel)
            
            if not curriculum_chapter:
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error": "code_officiel_invalide",
                        "message": f"Le code officiel '{request.code_officiel}' n'existe pas dans le r√©f√©rentiel.",
                        "hint": "Utilisez un code au format 6e_N01, 6e_G01, etc."
                    }
                )
            
            # Utiliser les donn√©es legacy
            request.niveau = curriculum_chapter.niveau
            request.chapitre = curriculum_chapter.libelle or curriculum_chapter.code_officiel
            logger.warning(
                f"[CHAPTER_LOAD] source=json code={request.code_officiel} "
                f"(chapitre trouv√© dans JSON mais pas en DB - migration n√©cessaire)"
            )
        else:
            # Utiliser les donn√©es depuis MongoDB
            request.niveau = chapter_from_db.get("niveau", "6e")
            request.chapitre = chapter_from_db.get("libelle") or chapter_from_db.get("code_officiel", request.code_officiel)
            
            # P4.D - R√©cup√©rer enabled_generators depuis la DB
            enabled_generators_list = chapter_from_db.get("enabled_generators", [])
            
            logger.info(
                f"[CHAPTER_LOAD] source=db code={request.code_officiel} "
                f"enabled_generators={[eg.get('generator_key') for eg in enabled_generators_list if eg.get('is_enabled')]}"
            )
        
        # V√©rifier si c'est un chapitre de test (interdit en mode public)
        from curriculum.loader import is_test_chapter, should_show_test_chapters
        if is_test_chapter(request.code_officiel) and not should_show_test_chapters():
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "TEST_CHAPTER_FORBIDDEN",
                    "error": "test_chapter_forbidden",
                    "message": f"Le code officiel '{request.code_officiel}' est un chapitre de test et n'est pas accessible en mode public.",
                    "hint": "Les chapitres de test sont r√©serv√©s au d√©veloppement. Activez SHOW_TEST_CHAPTERS=true pour y acc√©der.",
                    "context": {
                        "code_officiel": request.code_officiel,
                        "is_test_chapter": True
                    }
                }
            )
        
        # ============================================================================
        # D√âTECTION CHAPITRES DE TEST - Routage d√©terministe pour chapitres de test
        # ============================================================================
        # Chapitres de test connus qui utilisent le pipeline MIXED (exercices dynamiques)
        TEST_CHAPTER_CODES = ["6E_AA_TEST", "6E_TESTS_DYN", "6E_MIXED_QA"]
        normalized_code = request.code_officiel.upper().replace("-", "_")
        
        if normalized_code in TEST_CHAPTER_CODES:
            # Chapitre de test connu : utiliser directement le pipeline MIXED
            logger.info(f"[TEST_CHAPTER] Chapitre de test d√©tect√©: {request.code_officiel} ‚Üí pipeline=MIXED")
            pipeline_mode = "MIXED"
        else:
            # V√©rifier si c'est un chapitre de test inconnu (pattern AA_* ou *_TEST)
            if "_AA_" in normalized_code or normalized_code.endswith("_TEST") or "_TESTS_" in normalized_code:
                # Chapitre de test inconnu : retourner 422 avec hint clair
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "TEST_CHAPTER_UNKNOWN",
                        "error": "test_chapter_unknown",
                        "message": f"Le code officiel '{request.code_officiel}' semble √™tre un chapitre de test mais n'est pas configur√©.",
                        "hint": f"Chapitres de test connus: {', '.join(TEST_CHAPTER_CODES)}. Ajoutez '{normalized_code}' √† la liste TEST_CHAPTER_CODES dans exercises_routes.py si c'est un nouveau chapitre de test.",
                        "context": {
                            "code_officiel": request.code_officiel,
                            "normalized_code": normalized_code,
                            "known_test_chapters": TEST_CHAPTER_CODES
                        }
                    }
                )
            
            # ============================================================================
            # P0: PIPELINE EXPLICITE - Routage selon pipeline du chapitre
            # ============================================================================
            # Si le chapitre a un pipeline d√©fini, l'utiliser explicitement.
            # Sinon, fallback sur l'ancien comportement (d√©tection automatique).
            
            # P4.D - Utiliser le pipeline depuis la DB si disponible, sinon depuis legacy
            if chapter_from_db:
                pipeline_mode = chapter_from_db.get("pipeline")
            elif curriculum_chapter:
                pipeline_mode = curriculum_chapter.pipeline if hasattr(curriculum_chapter, 'pipeline') and curriculum_chapter.pipeline else None
            else:
                pipeline_mode = None
        
        if pipeline_mode:
            logger.info(f"[PIPELINE] Chapitre {request.code_officiel} ‚Üí pipeline={pipeline_mode} (explicite)")
            
            from server import db
            from backend.services.curriculum_sync_service import get_curriculum_sync_service
            from backend.services.exercise_persistence_service import get_exercise_persistence_service
            from backend.services.tests_dyn_handler import format_dynamic_exercise
            
            sync_service = get_curriculum_sync_service(db)
            exercise_service = get_exercise_persistence_service(db)
            
            # Normaliser le code_officiel pour la recherche
            # Utiliser normalized_code_officiel d√©fini plus haut
            chapter_code_for_db = normalized_code_officiel if normalized_code_officiel else request.code_officiel.upper().replace("-", "_")
            
            # P0 - DIAGNOSTIC COMPLET pour 6E_G07
            logger.info(
                f"[PIPELINE_DEBUG] ========================================="
            )
            logger.info(
                f"[PIPELINE_DEBUG] requested_code_officiel='{request.code_officiel}'"
            )
            logger.info(
                f"[PIPELINE_DEBUG] normalized_code='{normalized_code_officiel if normalized_code_officiel else chapter_code_for_db}'"
            )
            logger.info(
                f"[PIPELINE_DEBUG] chapter_from_db exists: {chapter_from_db is not None}"
            )
            if chapter_from_db:
                logger.info(
                    f"[PIPELINE_DEBUG] chapter_from_db.code_officiel='{chapter_from_db.get('code_officiel')}'"
                )
                logger.info(
                    f"[PIPELINE_DEBUG] pipeline_mode='{pipeline_mode}' (type: {type(pipeline_mode)})"
                )
            else:
                logger.warning(
                    f"[PIPELINE_DEBUG] ‚ö†Ô∏è chapter_from_db is None! "
                    f"Le chapitre n'a pas √©t√© trouv√© avec normalized_code='{normalized_code_officiel if normalized_code_officiel else chapter_code_for_db}'"
                )
            
            # P4.D - R√©cup√©rer enabled_generators depuis la DB si disponible
            enabled_generators_raw = []
            if chapter_from_db:
                enabled_generators_raw = chapter_from_db.get("enabled_generators", [])
            
            # P0 - FIX : Normaliser enabled_generators (peut √™tre List[str] ou List[dict])
            enabled_generators_for_chapter = normalize_enabled_generators(enabled_generators_raw)
            
            logger.info(
                f"[PIPELINE_DEBUG] enabled_generators_raw_type={type(enabled_generators_raw).__name__} "
                f"enabled_generators={enabled_generators_for_chapter}"
            )
            
            if pipeline_mode == "TEMPLATE":
                # Pipeline dynamique uniquement
                ctx = get_request_context()
                ctx.update({
                    'pipeline': 'TEMPLATE',
                    'chapter_code': chapter_code_for_db,
                })
                obs_logger.info(
                    "event=mixed_decision",
                    event="mixed_decision",
                    outcome="in_progress",
                    chosen_path="TEMPLATE",
                    chapter=chapter_code_for_db,
                    **ctx
                )
                try:
                    has_exercises = await sync_service.has_exercises_in_db(chapter_code_for_db)
                    if not has_exercises:
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "TEMPLATE_PIPELINE_NO_DYNAMIC_EXERCISES",
                                "error": "template_pipeline_no_exercises",
                                "message": (
                                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                                    f"mais aucun exercice dynamique n'existe en DB pour ce chapitre."
                                ),
                                "chapter_code": request.code_officiel,
                                "pipeline": "TEMPLATE",
                                "hint": "Cr√©ez au moins un exercice dynamique pour ce chapitre ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                            }
                        )
                    
                    exercises = await exercise_service.get_exercises(
                        chapter_code=chapter_code_for_db,
                        offer=request.offer if hasattr(request, 'offer') else None,
                        difficulty=request.difficulte if hasattr(request, 'difficulte') else None
                    )
                    dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
                    
                    # P4.D - Filtrer selon enabled_generators si disponible
                    # enabled_generators_for_chapter est d√©j√† normalis√© plus haut
                    if enabled_generators_for_chapter:
                        dynamic_exercises = [
                            ex for ex in dynamic_exercises
                            if ex.get("generator_key") and ex.get("generator_key").upper() in enabled_generators_for_chapter
                        ]
                        logger.info(
                            f"[PROF_GENERATORS] Filtr√© {len(dynamic_exercises)} exercices dynamiques "
                            f"parmi {len([ex for ex in exercises if ex.get('is_dynamic')])} "
                            f"selon enabled_generators={enabled_generators_for_chapter}"
                        )
                    
                    if len(dynamic_exercises) == 0:
                        # P4.D - Message am√©lior√© selon si enabled_generators est vide
                        if enabled_generators_for_chapter:
                            hint_msg = (
                                f"Aucun exercice dynamique trouv√© pour les g√©n√©rateurs activ√©s: {', '.join(enabled_generators_for_chapter)}. "
                                f"Cr√©ez des exercices dynamiques pour ces g√©n√©rateurs ou activez d'autres g√©n√©rateurs dans l'admin."
                            )
                        else:
                            hint_msg = (
                                f"Aucun g√©n√©rateur activ√© pour ce chapitre. "
                                f"Activez au moins un g√©n√©rateur dans l'admin (section 'G√©n√©rateurs activ√©s')."
                            )
                        
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "TEMPLATE_PIPELINE_NO_DYNAMIC_EXERCISES",
                                "error": "template_pipeline_no_dynamic_exercises",
                                "message": (
                                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                                    f"mais aucun exercice dynamique (is_dynamic=true) n'existe en DB pour ce chapitre."
                                ),
                                "chapter_code": request.code_officiel,
                                "pipeline": "TEMPLATE",
                                "hint": hint_msg,
                                "enabled_generators": enabled_generators_for_chapter if enabled_generators_for_chapter else None
                            }
                        )
                    
                    # P4.D - Guardrail : v√©rifier que le g√©n√©rateur s√©lectionn√© est activ√©
                    selected_exercise = safe_random_choice(dynamic_exercises, ctx, obs_logger)
                    selected_generator_key = selected_exercise.get("generator_key")
                    
                    if enabled_generators_for_chapter and selected_generator_key:
                        if selected_generator_key.upper() not in [eg.upper() for eg in enabled_generators_for_chapter]:
                            logger.warning(
                                f"[PROF_GENERATORS] Guardrail: g√©n√©rateur '{selected_generator_key}' "
                                f"non activ√© pour {chapter_code_for_db}. Activ√©s: {enabled_generators_for_chapter}"
                            )
                            # Filtrer √† nouveau pour s'assurer qu'on utilise un g√©n√©rateur activ√©
                            dynamic_exercises_filtered = [
                                ex for ex in dynamic_exercises
                                if ex.get("generator_key") and ex.get("generator_key").upper() in [eg.upper() for eg in enabled_generators_for_chapter]
                            ]
                            if dynamic_exercises_filtered:
                                selected_exercise = safe_random_choice(dynamic_exercises_filtered, ctx, obs_logger)
                                selected_generator_key = selected_exercise.get("generator_key")
                            else:
                                raise HTTPException(
                                    status_code=403,
                                    detail={
                                        "error_code": "GENERATOR_NOT_ENABLED",
                                        "error": "generator_not_enabled",
                                        "message": (
                                            f"Le g√©n√©rateur '{selected_generator_key}' n'est pas activ√© pour le chapitre '{request.code_officiel}'. "
                                            f"G√©n√©rateurs activ√©s: {', '.join(enabled_generators_for_chapter) if enabled_generators_for_chapter else 'aucun'}."
                                        ),
                                        "hint": "Activez ce g√©n√©rateur dans l'admin (section 'G√©n√©rateurs activ√©s') ou utilisez un autre g√©n√©rateur.",
                                        "context": {
                                            "chapter_code": request.code_officiel,
                                            "generator_key": selected_generator_key,
                                            "enabled_generators": enabled_generators_for_chapter
                                        }
                                    }
                                )
                    
                    # G√©n√©rer l'exercice dynamique
                    timestamp = int(time.time() * 1000)
                    dyn_exercise = format_dynamic_exercise(
                        exercise_template=selected_exercise,
                        timestamp=timestamp,
                        seed=request.seed
                    )
                    
                    duration_ms = int((time.time() - request_start) * 1000)
                    obs_logger.info(
                        "event=request_complete",
                        event="request_complete",
                        outcome="success",
                        duration_ms=duration_ms,
                        chosen_path="TEMPLATE",
                        exercise_id=selected_exercise.get('id'),
                        generator_key=selected_exercise.get('generator_key'),
                        **ctx
                    )
                    logger.info(
                        f"[PIPELINE] ‚úÖ Exercice dynamique g√©n√©r√© (TEMPLATE): "
                        f"chapter_code={chapter_code_for_db}, exercise_id={selected_exercise.get('id')}, "
                        f"generator_key={selected_exercise.get('generator_key')}"
                    )
                    
                    return dyn_exercise
                except HTTPException as e:
                    duration_ms = int((time.time() - request_start) * 1000)
                    obs_logger.error(
                        "event=request_error",
                        event="request_error",
                        outcome="error",
                        duration_ms=duration_ms,
                        reason="http_exception",
                        error_code=e.detail.get('error_code', None) if isinstance(e.detail, dict) else None,
                        **ctx
                    )
                    raise
                except Exception as e:
                    duration_ms = int((time.time() - request_start) * 1000)
                    obs_logger.error(
                        "event=request_exception",
                        event="request_exception",
                        outcome="error",
                        duration_ms=duration_ms,
                        reason="template_pipeline_error",
                        exception_type=type(e).__name__,
                        **ctx,
                        exc_info=True
                    )
                    logger.error(
                        f"[PIPELINE] Erreur pipeline TEMPLATE pour {chapter_code_for_db}: {e}"
                    )
                    raise HTTPException(
                        status_code=500,
                        detail={
                            "error_code": "TEMPLATE_PIPELINE_ERROR",
                            "error": "template_pipeline_error",
                            "message": f"Erreur lors de la g√©n√©ration avec pipeline TEMPLATE: {str(e)}"
                        }
                    )
            
            elif pipeline_mode == "MIXED":
                # P0 - SIMPLIFICATION : Utiliser le pipeline DYNAMIC ‚Üí STATIC fallback
                ctx = get_request_context()
                ctx.update({
                    'pipeline': 'MIXED',
                    'chapter_code': chapter_code_for_db,
                })
                obs_logger.info(
                    "event=mixed_decision",
                    event="mixed_decision",
                    outcome="in_progress",
                    chosen_path="MIXED",
                    chapter=chapter_code_for_db,
                    **ctx
                )
                try:
                    # P4.D - Passer enabled_generators dans le contexte
                    ctx["enabled_generators"] = enabled_generators_for_chapter
                    
                    # Utiliser le pipeline simplifi√© : DYNAMIC ‚Üí STATIC fallback
                    return await generate_exercise_with_fallback(
                        chapter_code=chapter_code_for_db,
                        exercise_service=exercise_service,
                        request=request,
                        ctx=ctx,
                        request_start=request_start,
                        effective_grade=effective_grade  # P0 - Passer le grade effectif
                    )
                except HTTPException:
                    raise
                except Exception as e:
                    logger.error(f"[P0] Erreur pipeline MIXED pour {chapter_code_for_db}: {e}")
                    raise HTTPException(
                        status_code=500,
                        detail={
                            "error_code": "MIXED_PIPELINE_ERROR",
                            "error": "mixed_pipeline_error",
                            "message": f"Erreur lors de la g√©n√©ration avec pipeline MIXED: {str(e)}"
                        }
                    )
                
                # ANCIEN CODE MIXED (d√©sactiv√© - trop complexe)
                # try:
                    has_exercises = await sync_service.has_exercises_in_db(chapter_code_for_db)
                    if has_exercises:
                        # R√©cup√©rer les exercices avec filtres
                        exercises = await exercise_service.get_exercises(
                            chapter_code=chapter_code_for_db,
                            offer=request.offer if hasattr(request, 'offer') else None,
                            difficulty=request.difficulte if hasattr(request, 'difficulte') else None
                        )
                        dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
                        static_exercises = [ex for ex in exercises if ex.get("is_dynamic") is not True]
                        
                        # Log du pool filtr√© pour diagnostic
                        obs_logger.debug(
                            "event=mixed_pool_filtered",
                            event="mixed_pool_filtered",
                            outcome="in_progress",
                            filters_applied={
                                "offer": request.offer if hasattr(request, 'offer') else None,
                                "difficulty": request.difficulte if hasattr(request, 'difficulte') else None
                            },
                            dynamic_count=len(dynamic_exercises),
                            static_count=len(static_exercises),
                            total_count=len(exercises),
                            **ctx
                        )
                        
                        # Si aucun exercice avec filtres, retenter sans filtres (d√©grad√©)
                        if len(dynamic_exercises) == 0 and len(static_exercises) == 0:
                            obs_logger.warning(
                                "event=mixed_no_filtered_exercises",
                                event="mixed_no_filtered_exercises",
                                outcome="warning",
                                reason="no_exercises_with_filters",
                                filters_applied={
                                    "offer": request.offer if hasattr(request, 'offer') else None,
                                    "difficulty": request.difficulte if hasattr(request, 'difficulte') else None
                                },
                                **ctx
                            )
                            exercises = await exercise_service.get_exercises(
                                chapter_code=chapter_code_for_db,
                                offer=None,
                                difficulty=None
                            )
                            dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
                            static_exercises = [ex for ex in exercises if ex.get("is_dynamic") is not True]
                        # 1) Dyn filtr√©
                        if len(dynamic_exercises) > 0:
                            selected_exercise = safe_random_choice(dynamic_exercises, ctx, obs_logger)
                            timestamp = int(time.time() * 1000)
                            dyn_exercise = format_dynamic_exercise(
                                exercise_template=selected_exercise,
                                timestamp=timestamp,
                                seed=request.seed
                            )
                            duration_ms = int((time.time() - request_start) * 1000)
                            obs_logger.info(
                                "event=request_complete",
                                event="request_complete",
                                outcome="success",
                                duration_ms=duration_ms,
                                chosen_path="MIXED_dynamic_filtered",
                                exercise_id=selected_exercise.get('id'),
                                **ctx
                            )
                            logger.info(
                                f"[PIPELINE] ‚úÖ Exercice dynamique g√©n√©r√© (MIXED, priorit√© dynamique): "
                                f"chapter_code={chapter_code_for_db}, exercise_id={selected_exercise.get('id')}"
                            )
                            return dyn_exercise
                        
                        # 2) Dyn sans filtre (d√©grad√©)
                        dynamic_all = [ex for ex in exercises if ex.get("is_dynamic") is True]
                        if dynamic_all:
                            obs_logger.warning(
                                "event=fallback",
                                event="fallback",
                                outcome="success",
                                reason="no_filtered_dynamic",
                                pool_size=len(dynamic_all),
                                **ctx
                            )
                            selected_exercise = safe_random_choice(dynamic_all, ctx, obs_logger)
                            timestamp = int(time.time() * 1000)
                            dyn_exercise = format_dynamic_exercise(
                                exercise_template=selected_exercise,
                                timestamp=timestamp,
                                seed=request.seed
                            )
                            dyn_exercise.setdefault("metadata", {}).update({"fallback_filters": True})
                            duration_ms = int((time.time() - request_start) * 1000)
                            obs_logger.info(
                                "event=request_complete",
                                event="request_complete",
                                outcome="success",
                                duration_ms=duration_ms,
                                chosen_path="MIXED_dynamic_degraded",
                                exercise_id=selected_exercise.get('id'),
                                **ctx
                            )
                            logger.info(
                                f"[PIPELINE] ‚úÖ Exercice dynamique g√©n√©r√© (MIXED d√©grad√©, sans filtre offer/difficulty): "
                                f"chapter_code={chapter_code_for_db}, exercise_id={selected_exercise.get('id')}"
                            )
                            return dyn_exercise
                        
                        # Pool vide : aucun exercice dynamique disponible
                        obs_logger.error(
                            "event=pool_empty",
                            event="pool_empty",
                            outcome="error",
                            reason="no_dynamic_exercises_available",
                            pool_size=0,
                            **ctx
                        )
                        # P4.D - Message am√©lior√© selon si enabled_generators est vide
                        if enabled_generators_for_chapter:
                            hint_msg = (
                                f"Aucun exercice dynamique trouv√© pour les g√©n√©rateurs activ√©s: {', '.join(enabled_generators_for_chapter)}. "
                                f"Cr√©ez des exercices dynamiques pour ces g√©n√©rateurs ou activez d'autres g√©n√©rateurs dans l'admin."
                            )
                        else:
                            hint_msg = (
                                f"Aucun g√©n√©rateur activ√© pour ce chapitre. "
                                f"Activez au moins un g√©n√©rateur dans l'admin (section 'G√©n√©rateurs activ√©s')."
                            )
                        
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "POOL_EMPTY",
                                "error": "pool_empty",
                                "message": f"Aucun exercice dynamique disponible pour ce chapitre avec les crit√®res demand√©s.",
                                "hint": hint_msg,
                                "context": {
                                    "chapter": chapter_code_for_db,
                                    "difficulty": request.difficulte,
                                    "offer": request.offer,
                                    "pipeline": "MIXED",
                                    "enabled_generators": enabled_generators_for_chapter if enabled_generators_for_chapter else None
                                }
                            }
                        )
                        
                        # 3) Statiques filtr√©s
                        if len(static_exercises) > 0:
                            obs_logger.warning(
                                "event=fallback",
                                event="fallback",
                                outcome="success",
                                reason="no_dynamic_fallback_static",
                                pool_size=len(static_exercises),
                                **ctx
                            )
                            selected_static = safe_random_choice(static_exercises, ctx, obs_logger)
                            timestamp = int(time.time() * 1000)
                            static_exercise = {
                                "id_exercice": f"admin_static_{chapter_code_for_db}_{selected_static.get('id')}_{timestamp}",
                                "niveau": curriculum_chapter.niveau,
                                "chapitre": curriculum_chapter.libelle or curriculum_chapter.code_officiel,
                                "enonce_html": selected_static.get("enonce_html") or "",
                                "solution_html": selected_static.get("solution_html") or "",
                                "needs_svg": selected_static.get("needs_svg") or False,
                                "pdf_token": f"admin_static_{chapter_code_for_db}_{selected_static.get('id')}_{timestamp}",
                                "metadata": {
                                    "offer": selected_static.get("offer"),
                                    "difficulty": selected_static.get("difficulty"),
                                    "source": "admin_exercises_static",
                                    "is_fallback": False
                                }
                            }
                            duration_ms = int((time.time() - request_start) * 1000)
                            obs_logger.info(
                                "event=request_complete",
                                event="request_complete",
                                outcome="success",
                                duration_ms=duration_ms,
                                chosen_path="MIXED_static_fallback",
                                exercise_id=selected_static.get('id'),
                                **ctx
                            )
                            logger.info(
                                f"[PIPELINE] ‚úÖ Exercice statique (admin) g√©n√©r√© (MIXED fallback statique): "
                                f"chapter_code={chapter_code_for_db}, exercise_id={selected_static.get('id')}"
                            )
                            return static_exercise
                        
                        # 4) Aucun exo ‚Üí 422 explicite avec logs d√©taill√©s
                        # R√©cup√©rer les statistiques pour diagnostic
                        all_exercises = await exercise_service.get_exercises(
                            chapter_code=chapter_code_for_db,
                            offer=None,
                            difficulty=None
                        )
                        all_dynamic = [ex for ex in all_exercises if ex.get("is_dynamic") is True]
                        all_static = [ex for ex in all_exercises if ex.get("is_dynamic") is not True]
                        
                        # Compter par difficulty/offer pour diagnostic
                        by_difficulty = {}
                        by_offer = {}
                        for ex in all_exercises:
                            diff = ex.get("difficulty", "unknown")
                            off = ex.get("offer", "unknown")
                            by_difficulty[diff] = by_difficulty.get(diff, 0) + 1
                            by_offer[off] = by_offer.get(off, 0) + 1
                        
                        obs_logger.error(
                            "event=mixed_no_exercises",
                            event="mixed_no_exercises",
                            outcome="error",
                            reason="list_empty",
                            filters_applied={
                                "offer": request.offer if hasattr(request, 'offer') else None,
                                "difficulty": request.difficulte if hasattr(request, 'difficulte') else None
                            },
                            total_exercises_in_db=len(all_exercises),
                            total_dynamic_in_db=len(all_dynamic),
                            total_static_in_db=len(all_static),
                            by_difficulty=by_difficulty,
                            by_offer=by_offer,
                            **ctx
                        )
                        
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "MIXED_PIPELINE_NO_EXERCISES_OR_TYPES",
                                "error": "mixed_pipeline_no_exercises_or_types",
                                "message": (
                                    f"Aucun exercice (dynamique ou statique) pour {chapter_code_for_db} "
                                    f"avec offer='{request.offer}' et difficulte='{request.difficulte}'. "
                                    "Ajoutez un exercice pour ces filtres ou changez de difficult√©/offre."
                                ),
                                "chapter_code": chapter_code_for_db,
                                "pipeline": "MIXED",
                                "filters": {
                                    "offer": getattr(request, 'offer', None),
                                    "difficulty": getattr(request, 'difficulte', None)
                                },
                                "diagnostic": {
                                    "total_exercises_in_db": len(all_exercises),
                                    "total_dynamic": len(all_dynamic),
                                    "total_static": len(all_static),
                                    "by_difficulty": by_difficulty,
                                    "by_offer": by_offer
                                }
                            }
                        )
                    
                    # Fallback sur pipeline statique
                    obs_logger.warning(
                        "event=fallback",
                        event="fallback",
                        outcome="in_progress",
                        reason="no_exercises_fallback_static",
                        **ctx
                    )
                    logger.info(
                        f"[PIPELINE] Pipeline MIXED pour {chapter_code_for_db}: pas d'exercices dynamiques, "
                        f"utilisation du pipeline STATIQUE."
                    )
                    # Continue vers pipeline statique (code ci-dessous)
                except Exception as e:
                    obs_logger.warning(
                        "event=fallback",
                        event="fallback",
                        outcome="in_progress",
                        reason="exception_fallback_static",
                        exception_type=type(e).__name__,
                        **ctx
                    )
                    logger.warning(
                        f"[PIPELINE] Erreur v√©rification exercices dynamiques (MIXED) pour {chapter_code_for_db}: {e}. "
                        f"Fallback sur pipeline STATIQUE."
                    )
                    # Continue vers pipeline statique (code ci-dessous)
            
            elif pipeline_mode == "SPEC":
                # Pipeline statique uniquement - continue vers le code ci-dessous
                ctx = get_request_context()
                ctx.update({
                    'pipeline': 'SPEC',
                    'chapter_code': chapter_code_for_db,
                })
                obs_logger.info(
                    "event=mixed_decision",
                    event="mixed_decision",
                    outcome="in_progress",
                    chosen_path="SPEC",
                    chapter=chapter_code_for_db,
                    **ctx
                )
                logger.info(f"[PIPELINE] Pipeline SPEC pour {chapter_code_for_db}: utilisation du pipeline STATIQUE.")
                try:
                    # Utiliser en priorit√© les exercices statiques saisis en admin
                    exercises = await exercise_service.get_exercises(
                        chapter_code=chapter_code_for_db,
                        offer=request.offer if hasattr(request, 'offer') else None,
                        difficulty=request.difficulte if hasattr(request, 'difficulte') else None
                    )
                    static_exercises = [ex for ex in exercises if ex.get("is_dynamic") is not True]
                    if not static_exercises:
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "NO_EXERCISE_AVAILABLE",
                                "error": "no_exercise_available",
                                "message": (
                                    f"Aucun exercice statique saisi pour {chapter_code_for_db} "
                                    f"avec offer='{request.offer}' et difficulte='{request.difficulte}'. "
                                    "Ajoutez un exercice statique ou d√©finissez exercise_types pour la g√©n√©ration SPEC."
                                ),
                                "chapter_code": chapter_code_for_db,
                                "pipeline": "SPEC",
                                "filters": {
                                    "offer": getattr(request, 'offer', None),
                                    "difficulty": getattr(request, 'difficulte', None)
                                }
                            }
                        )
                        if static_exercises:
                            selected_static = safe_random_choice(static_exercises, ctx, obs_logger)
                        timestamp = int(time.time() * 1000)
                        static_exercise = {
                            "id_exercice": f"admin_static_{chapter_code_for_db}_{selected_static.get('id')}_{timestamp}",
                            "niveau": curriculum_chapter.niveau,
                            "chapitre": curriculum_chapter.libelle or curriculum_chapter.code_officiel,
                            "enonce_html": selected_static.get("enonce_html") or "",
                            "solution_html": selected_static.get("solution_html") or "",
                            "needs_svg": selected_static.get("needs_svg") or False,
                            "exercise_type": selected_static.get("exercise_type"),
                            "pdf_token": f"admin_static_{chapter_code_for_db}_{selected_static.get('id')}_{timestamp}",
                            "metadata": {
                                "offer": selected_static.get("offer"),
                                "difficulty": selected_static.get("difficulty"),
                                "source": "admin_exercises_static",
                                "is_fallback": False
                            }
                        }
                        logger.info(
                            f"[PIPELINE] ‚úÖ Exercice statique (admin) g√©n√©r√© (SPEC): "
                            f"chapter_code={chapter_code_for_db}, exercise_id={selected_static.get('id')}"
                        )
                        return static_exercise
                except Exception as e:
                    logger.warning(
                        f"[PIPELINE] Erreur r√©cup√©ration exercices statiques (SPEC) pour {chapter_code_for_db}: {e}. "
                        f"Fallback sur pipeline STATIQUE legacy."
                    )
                # Continue vers pipeline statique (code ci-dessous)
        
        else:
            # P0 - Pipeline absent : utiliser le pipeline AUTO (DYNAMIC ‚Üí STATIC fallback)
            logger.info(
                f"[P0] Chapitre {request.code_officiel} n'a pas de pipeline d√©fini. "
                f"Utilisation du pipeline AUTO (DYNAMIC ‚Üí STATIC fallback)."
            )
            
            from server import db
            from backend.services.curriculum_sync_service import get_curriculum_sync_service
            from backend.services.exercise_persistence_service import get_exercise_persistence_service
            
            sync_service = get_curriculum_sync_service(db)
            exercise_service = get_exercise_persistence_service(db)
            
            chapter_code_for_db = request.code_officiel.upper().replace("-", "_")
            
            ctx = get_request_context()
            ctx.update({
                'pipeline': 'AUTO',
                'chapter_code': chapter_code_for_db,
            })
            
            # Utiliser le pipeline simplifi√© : DYNAMIC ‚Üí STATIC fallback
            return await generate_exercise_with_fallback(
                chapter_code=chapter_code_for_db,
                exercise_service=exercise_service,
                request=request,
                ctx=ctx,
                request_start=request_start
            )
        
        # Convertir les types d'exercices du r√©f√©rentiel en enum
        # IMPORTANT:
        # - En mode gratuit, filtrer les g√©n√©rateurs premium
        # - Ne JAMAIS faire de fallback silencieux vers le mapping legacy
        #   si des exercise_types configur√©s sont inconnus.
        if curriculum_chapter.exercise_types:
            try:
                # P2.1 - FILTRAGE DATA-DRIVEN DES G√âN√âRATEURS PREMIUM
                # Au lieu d'une liste hardcod√©e, v√©rifier meta.min_offer pour chaque g√©n√©rateur
                if request.offer == "pro":
                    # Mode PRO: tous les g√©n√©rateurs disponibles
                    filtered_types = curriculum_chapter.exercise_types
                else:
                    # Mode gratuit: exclure dynamiquement les g√©n√©rateurs avec min_offer="pro"
                    filtered_types = []
                    for et in curriculum_chapter.exercise_types:
                        # V√©rifier si c'est un g√©n√©rateur Factory
                        gen_class = GeneratorFactory.get(et)
                        if gen_class:
                            gen_meta = gen_class.get_meta()
                            required_offer = getattr(gen_meta, 'min_offer', 'free')
                            if required_offer == "free":
                                filtered_types.append(et)
                            else:
                                filtered_premium_generators.append(et)
                                logger.info(f"[FILTER] G√©n√©rateur {et} exclu (min_offer={required_offer}, user_offer=free)")
                        else:
                            # Pas un g√©n√©rateur Factory, inclure par d√©faut
                            filtered_types.append(et)
                
                # Conversion stricte vers MathExerciseType
                valid_types = []
                invalid_types = []
                for et in filtered_types:
                    if hasattr(MathExerciseType, et):
                        valid_types.append(MathExerciseType[et])
                    else:
                        invalid_types.append(et)
                
                exercise_types_override = valid_types
                
                # Si au moins un type est valide mais certains sont inconnus:
                # - on log un warning explicite,
                # - mais on continue avec les types valides uniquement.
                if invalid_types and valid_types:
                    logger.warning(
                        f"Certains exercise_types sont inconnus pour {request.code_officiel} "
                        f"(ignor√©s): {invalid_types}"
                    )
                
                # P0: Validation BLOQUANTE pour pipeline SPEC
                # Si TOUS les types configur√©s sont inconnus, lever une erreur claire
                # plut√¥t que de retomber silencieusement sur le mapping legacy.
                if filtered_types and not valid_types:
                    # V√©rifier si le pipeline est SPEC (validation bloquante)
                    pipeline_mode = curriculum_chapter.pipeline if hasattr(curriculum_chapter, 'pipeline') and curriculum_chapter.pipeline else None
                    if pipeline_mode == "SPEC":
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "SPEC_PIPELINE_INVALID_EXERCISE_TYPES",
                                "error": "spec_pipeline_invalid_exercise_types",
                                "message": (
                                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='SPEC' "
                                    f"mais tous les exercise_types configur√©s ne correspondent √† aucun "
                                    f"MathExerciseType connu: {filtered_types}."
                                ),
                                "chapter_code": request.code_officiel,
                                "pipeline": "SPEC",
                                "exercise_types_configured": filtered_types,
                                "hint": (
                                    "Ajoutez ces types dans MathExerciseType, corrigez le r√©f√©rentiel curriculum_6e, "
                                    "ou changez le pipeline √† 'TEMPLATE' ou 'MIXED'."
                                ),
                            },
                        )
                    else:
                        # Comportement legacy pour compatibilit√©
                        raise HTTPException(
                            status_code=422,
                            detail={
                                "error_code": "INVALID_CURRICULUM_EXERCISE_TYPES",
                                "error": "invalid_exercise_types",
                                "message": (
                                    f"Les exercise_types configur√©s pour le chapitre "
                                    f"'{request.code_officiel}' ne correspondent √† aucun "
                                    f"MathExerciseType connu: {filtered_types}."
                                ),
                                "chapter_code": request.code_officiel,
                                "exercise_types_configured": filtered_types,
                                "hint": (
                                    "Ajoutez ces types dans MathExerciseType ou corrigez "
                                    "le r√©f√©rentiel curriculum_6e."
                                ),
                            },
                        )
                
                logger.info(
                    f"Types d'exercices filtr√©s pour {request.code_officiel} "
                    f"(offer={request.offer}): {filtered_types}"
                )
            except HTTPException:
                # Propager l'erreur structur√©e telle quelle
                raise
            except Exception as e:
                logger.warning(
                    f"Erreur conversion exercise_types pour {request.code_officiel}: {e}"
                )
        
        logger.info(
            f"G√©n√©ration exercice (mode officiel): code={request.code_officiel}, "
            f"chapitre_backend={request.chapitre}, exercise_types={curriculum_chapter.exercise_types}"
        )
    else:
        # Mode legacy : utiliser niveau + chapitre directement
        logger.info(
            f"G√©n√©ration exercice (mode legacy): niveau={request.niveau}, "
            f"chapitre={request.chapitre}, difficult√©={request.difficulte}"
        )
    
    # ============================================================================
    # 1. VALIDATION DU NIVEAU
    # ============================================================================
    
    if not curriculum_service.validate_niveau(request.niveau):
        niveaux_disponibles = curriculum_service.get_niveaux_disponibles()
        
        logger.warning(f"Niveau invalide: {request.niveau}")
        
        raise HTTPException(
            status_code=422,
            detail={
                "error": "niveau_invalide",
                "message": (
                    f"Le niveau '{request.niveau}' n'est pas reconnu. "
                    f"Niveaux disponibles : {', '.join(niveaux_disponibles)}."
                ),
                "niveaux_disponibles": niveaux_disponibles
            }
        )
    
    # ============================================================================
    # 2. VALIDATION DU CHAPITRE (sauf si code_officiel a √©t√© r√©solu)
    # ============================================================================
    
    if not curriculum_chapter:
        # Mode legacy : valider le chapitre
        if not curriculum_service.validate_chapitre(request.niveau, request.chapitre):
            chapitres_disponibles = curriculum_service.get_chapitres_disponibles(request.niveau)
            
            logger.warning(
                f"Chapitre invalide: {request.chapitre} pour niveau {request.niveau}"
            )
            
            raise HTTPException(
                status_code=422,
                detail={
                    "error": "chapitre_invalide",
                    "message": (
                        f"Le chapitre '{request.chapitre}' n'existe pas pour le niveau '{request.niveau}'. "
                        f"Chapitres disponibles : {', '.join(chapitres_disponibles[:10])}"
                        + ("..." if len(chapitres_disponibles) > 10 else ".")
                    ),
                    "niveau": request.niveau,
                    "chapitres_disponibles": chapitres_disponibles
                }
            )
    
    # ============================================================================
    # 3. G√âN√âRATION DE L'EXERCICE
    # ============================================================================
    
    try:
        # V1-BE-002-FIX: Utiliser l'instance globale (performance)
        # G√©n√©rer l'exercice avec le service math
        
        # P0.3 - PREMIUM DISPATCH G√âN√âRIQUE via GeneratorFactory
        use_premium_factory = False
        selected_premium_generator = None
        premium_result = None
        
        if request.offer == "pro" and request.code_officiel:
            # P4.D - Utiliser enabled_generators depuis la DB (source de v√©rit√© unique)
            factory_generator_keys = []
            
            if chapter_from_db and enabled_generators_list:
                # Filtrer uniquement les g√©n√©rateurs activ√©s (is_enabled=True)
                enabled_keys = [
                    eg.get("generator_key") 
                    for eg in enabled_generators_list 
                    if eg.get("is_enabled") is True
                ]
                
                # V√©rifier que ces g√©n√©rateurs existent dans GeneratorFactory
                available_factory_generators = list(GeneratorFactory._generators.keys())
                factory_generator_keys = [
                    gen_key for gen_key in enabled_keys 
                    if gen_key.upper() in available_factory_generators
                ]
                
                logger.info(
                    f"[PROF_GENERATORS] chapter={request.code_officiel} "
                    f"enabled_in_db={enabled_keys} resolved={factory_generator_keys}"
                )
            else:
                # Fallback legacy : utiliser exercise_types depuis JSON
                chapter_info = get_chapter_by_official_code(request.code_officiel)
                
                if chapter_info and hasattr(chapter_info, 'exercise_types'):
                    available_factory_generators = list(GeneratorFactory._generators.keys())
                    factory_generator_keys = [gen_key for gen_key in chapter_info.exercise_types 
                                             if gen_key in available_factory_generators]
                    
                    logger.warning(
                        f"[PROF_GENERATORS] chapter={request.code_officiel} "
                        f"source=legacy_json exercise_types={chapter_info.exercise_types} "
                        f"resolved={factory_generator_keys} (migration vers enabled_generators n√©cessaire)"
                    )
            
            if factory_generator_keys:
                    # S√©lectionner un g√©n√©rateur de fa√ßon d√©terministe si seed fourni
                    if request.seed is not None:
                        # D√©terministe : m√™me seed ‚Üí m√™me g√©n√©rateur
                        generator_index = request.seed % len(factory_generator_keys)
                        selected_premium_generator = factory_generator_keys[generator_index]
                    else:
                        # Al√©atoire (mais coh√©rent avec le comportement attendu)
                        import random
                        selected_premium_generator = random.choice(factory_generator_keys)
                    
                    # P2.1 - V√âRIFICATION DATA-DRIVEN DE L'OFFRE MINIMALE REQUISE
                    generator_class = GeneratorFactory.get(selected_premium_generator)
                    generator_meta = generator_class.get_meta() if generator_class else None
                    required_offer = getattr(generator_meta, 'min_offer', 'free') if generator_meta else 'free'
                    
                    if required_offer == "pro" and request.offer != "pro":
                        # Utilisateur free tente d'acc√©der √† un g√©n√©rateur premium
                        obs_logger.warning(
                            "event=premium_required",
                            event="premium_required",
                            outcome="error",
                            generator_key=selected_premium_generator,
                            required_offer=required_offer,
                            user_offer=request.offer,
                            **ctx
                        )
                        raise HTTPException(
                            status_code=403,
                            detail={
                                "error_code": "PREMIUM_REQUIRED",
                                "error": "premium_required",
                                "message": f"Ce g√©n√©rateur ({generator_meta.label}) est r√©serv√© √† l'offre Pro.",
                                "hint": "Passez √† l'offre Pro pour acc√©der √† ce contenu.",
                                "context": {
                                    "generator_key": selected_premium_generator,
                                    "required_offer": required_offer,
                                    "current_offer": request.offer
                                }
                            }
                        )
                    
                    logger.info(f"üåü Mode PREMIUM Factory activ√© pour {request.code_officiel} ‚Üí {selected_premium_generator}")
                    obs_logger.info(
                        "event=premium_factory_selected",
                        event="premium_factory_selected",
                        outcome="in_progress",
                        generator_key=selected_premium_generator,
                        available_generators=factory_generator_keys,
                        **ctx
                    )
                    
                    try:
                        # P0 - Construire effective_params (param√®tres effectifs apr√®s mapping)
                        requested_difficulty = request.difficulte if hasattr(request, 'difficulte') and request.difficulte else "moyen"
                        
                        # P0 - Appliquer map_ui_difficulty_to_generator() AVANT GeneratorFactory.generate()
                        generator_difficulty = map_ui_difficulty_to_generator(
                            selected_premium_generator,
                            requested_difficulty,
                            logger
                        )
                        
                        # P0 - Construire effective_params
                        effective_params = {
                            'difficulty_effective': generator_difficulty,
                            'grade_effective': effective_grade,
                            'seed': request.seed if hasattr(request, 'seed') and request.seed else None
                        }
                        
                        # Ajouter exercise_type si fourni
                        if hasattr(request, 'exercise_type') and request.exercise_type:
                            effective_params['exercise_type_effective'] = request.exercise_type
                            ui_params['exercise_type_ui'] = request.exercise_type
                        
                        if generator_difficulty != requested_difficulty:
                            obs_logger.info(
                                "event=difficulty_mapped",
                                event="difficulty_mapped",
                                outcome="success",
                                ui_difficulty=requested_difficulty,
                                generator_difficulty=generator_difficulty,
                                generator_key=selected_premium_generator,
                                **ctx
                            )
                            logger.info(
                                f"[DIFFICULTY_MAPPED] generator={selected_premium_generator} "
                                f"ui={requested_difficulty} -> effective={generator_difficulty}"
                            )
                        
                        # P0 - Logs avec ui_params et effective_params (sans donn√©es sensibles)
                        logger.info(
                            f"[GENERATOR_PARAMS] generator_key={selected_premium_generator} "
                            f"code_officiel={request.code_officiel} "
                            f"ui_params={ui_params} effective_params={effective_params}"
                        )
                        
                        # Appeler GeneratorFactory.generate() avec la difficult√© mapp√©e
                        overrides_dict = {
                            'seed': request.seed if hasattr(request, 'seed') and request.seed else None,
                            'grade': effective_grade,
                            'difficulty': generator_difficulty,  # P0 - Utiliser la difficult√© mapp√©e
                        }
                        
                        # Ajouter exercise_type si fourni
                        if hasattr(request, 'exercise_type') and request.exercise_type:
                            overrides_dict['exercise_type'] = request.exercise_type
                        
                        premium_result = GeneratorFactory.generate(
                            key=selected_premium_generator,
                            exercise_params={},
                            overrides=overrides_dict,
                            seed=request.seed if hasattr(request, 'seed') and request.seed else None
                        )
                        use_premium_factory = True
                        
                        obs_logger.info(
                            "event=premium_factory_success",
                            event="premium_factory_success",
                            outcome="success",
                            generator_key=selected_premium_generator,
                            **ctx
                        )
                    except Exception as e:
                        # Log l'erreur mais ne pas bloquer (fallback sur legacy)
                        obs_logger.error(
                            "event=premium_factory_error",
                            event="premium_factory_error",
                            outcome="error",
                            reason="generation_failed",
                            generator_key=selected_premium_generator,
                            error_message=str(e),
                            **ctx
                        )
                        logger.error(f"Erreur Factory {selected_premium_generator}: {e}")
                        use_premium_factory = False
        
        if use_premium_factory and premium_result:
            # P0.3 - Construire la r√©ponse directement depuis le g√©n√©rateur Factory
            obs_logger.info(
                "event=mixed_decision",
                event="mixed_decision",
                outcome="in_progress",
                chosen_path="premium_factory",
                **ctx
            )
            
            # R√©cup√©rer les variables depuis premium_result
            variables = premium_result.get("variables", {})
            
            # ============================================================================
            # P1 - S√âLECTION TEMPLATE DB-FIRST + FALLBACK LEGACY
            # ============================================================================
            # Tenter de r√©cup√©rer un template depuis la DB.
            # Si trouv√© : utiliser ce template (template_source="db")
            # Sinon : fallback sur templates hardcod√©s legacy (template_source="legacy")
            
            template_source = "legacy"  # Par d√©faut
            template_db_id = None
            variant_id = premium_result.get("variant_id", "default")  # Extraire variant_id si disponible
            
            # Tenter de r√©cup√©rer un template DB
            try:
                from server import db
                template_service = get_template_service(db)
                
                db_template = await template_service.get_best_template(
                    generator_key=selected_premium_generator,
                    variant_id=variant_id,
                    grade=request.niveau,
                    difficulty=request.difficulte
                )
                
                if db_template:
                    # Template DB trouv√© : utiliser celui-ci
                    enonce_template = db_template.enonce_template_html
                    solution_template = db_template.solution_template_html
                    template_source = "db"
                    template_db_id = db_template.id
                    
                    logger.info(
                        f"[TEMPLATE_DB] Template DB trouv√©: id={db_template.id}, "
                        f"generator={selected_premium_generator}, variant={variant_id}, "
                        f"grade={request.niveau}, difficulty={request.difficulte}"
                    )
                    obs_logger.info(
                        "event=template_db_selected",
                        event="template_db_selected",
                        outcome="success",
                        template_id=db_template.id,
                        generator_key=selected_premium_generator,
                        variant_id=variant_id,
                        **ctx
                    )
                else:
                    # Pas de template DB : fallback legacy
                    logger.info(
                        f"[TEMPLATE_LEGACY] Aucun template DB trouv√©, fallback sur legacy pour "
                        f"generator={selected_premium_generator}, variant={variant_id}"
                    )
                    obs_logger.info(
                        "event=template_legacy_fallback",
                        event="template_legacy_fallback",
                        outcome="success",
                        reason="no_db_template",
                        generator_key=selected_premium_generator,
                        variant_id=variant_id,
                        **ctx
                    )
                    
                    # P0.4 - Templates inline s√©curis√©s (pas de {{{enonce}}}, seulement {{{tableau_html}}})
                    # Ces templates sont coh√©rents avec ChapterExercisesAdminPage.js
                    enonce_template = """<div class="exercise-enonce">
  <p><strong>{{consigne}}</strong></p>
  <p>{{enonce}}</p>
  {{{tableau_html}}}
</div>"""
                    
                    solution_template = """<div class="exercise-solution">
  <h4 style="color: #2563eb; margin-bottom: 1rem;">{{methode}}</h4>
  <div class="calculs" style="background: #f1f5f9; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
    <pre style="white-space: pre-line; font-family: inherit; margin: 0;">{{calculs_intermediaires}}</pre>
  </div>
  <div class="solution-text" style="margin-bottom: 1rem;">
    <p>{{solution}}</p>
  </div>
  <div class="reponse-finale" style="background: #dcfce7; padding: 0.75rem; border-left: 4px solid #22c55e; border-radius: 0.25rem;">
    <p style="margin: 0;"><strong>R√©ponse finale :</strong> {{reponse_finale}}</p>
  </div>
</div>"""
            
            except Exception as e:
                # En cas d'erreur DB, fallback silencieux sur legacy
                logger.warning(
                    f"[TEMPLATE_DB_ERROR] Erreur lors de la r√©cup√©ration du template DB, "
                    f"fallback sur legacy: {e}"
                )
                obs_logger.warning(
                    "event=template_db_error",
                    event="template_db_error",
                    outcome="warning",
                    reason="db_error",
                    error_message=str(e),
                    generator_key=selected_premium_generator,
                    **ctx
                )
                
                # Templates legacy en fallback
                enonce_template = """<div class="exercise-enonce">
  <p><strong>{{consigne}}</strong></p>
  <p>{{enonce}}</p>
  {{{tableau_html}}}
</div>"""
                
                solution_template = """<div class="exercise-solution">
  <h4 style="color: #2563eb; margin-bottom: 1rem;">{{methode}}</h4>
  <div class="calculs" style="background: #f1f5f9; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem;">
    <pre style="white-space: pre-line; font-family: inherit; margin: 0;">{{calculs_intermediaires}}</pre>
  </div>
  <div class="solution-text" style="margin-bottom: 1rem;">
    <p>{{solution}}</p>
  </div>
  <div class="reponse-finale" style="background: #dcfce7; padding: 0.75rem; border-left: 4px solid #22c55e; border-radius: 0.25rem;">
    <p style="margin: 0;"><strong>R√©ponse finale :</strong> {{reponse_finale}}</p>
  </div>
</div>"""
            
            # Rendu HTML avec les variables du g√©n√©rateur
            enonce_html = render_template(enonce_template, variables)
            solution_html = render_template(solution_template, variables)
            
            # Pas besoin de specs, on construit directement la r√©ponse
            duration_ms = int((time.time() - request_start) * 1000)
            obs_logger.info(
                "event=request_complete",
                event="request_complete",
                outcome="success",
                duration_ms=duration_ms,
                chosen_path="premium_factory",
                generator_key=selected_premium_generator,
                **ctx
            )
            
            # Construire l'enonce_html et solution_html depuis premium_result
            id_exercice = generate_exercise_id(request.niveau, request.chapitre)
            pdf_token = id_exercice
            
            # P0 - Construire effective_params si pas d√©j√† fait
            if 'effective_params' not in locals():
                effective_params = {
                    'difficulty_effective': generator_difficulty if 'generator_difficulty' in locals() else request.difficulte,
                    'grade_effective': effective_grade,
                    'seed': request.seed if hasattr(request, 'seed') and request.seed else None
                }
                if hasattr(request, 'exercise_type') and request.exercise_type:
                    effective_params['exercise_type_effective'] = request.exercise_type
            
            # Retourner imm√©diatement la r√©ponse Factory
            metadata = {
                "is_premium": True,
                "generator_key": selected_premium_generator,
                "generator_code": f"{request.niveau}_{selected_premium_generator}",
                "difficulte": request.difficulte,
                "generation_duration_ms": duration_ms,
                "seed": request.seed if hasattr(request, 'seed') and request.seed else None,
                "variables": variables,  # Ajout des variables pour debug
                "template_source": template_source,  # P1 - Tra√ßabilit√© template (db | legacy)
                "ui_params": ui_params,  # P0 - Param√®tres UI bruts
                "effective_params": effective_params,  # P0 - Param√®tres effectifs apr√®s mapping
            }
            
            # Ajouter template_db_id si template DB utilis√©
            if template_db_id:
                metadata["template_db_id"] = template_db_id
            
            return ExerciseGenerateResponse(
                id_exercice=id_exercice,
                niveau=request.niveau,
                chapitre=request.chapitre,
                enonce_html=enonce_html,
                solution_html=solution_html,
                figure_svg=premium_result.get("figure_svg_enonce"),
                figure_svg_enonce=premium_result.get("figure_svg_enonce"),
                figure_svg_solution=premium_result.get("figure_svg_solution"),
                pdf_token=pdf_token,
                metadata=metadata
            )
        elif exercise_types_override and len(exercise_types_override) > 0:
            # Mode code_officiel : utiliser les types sp√©cifi√©s dans le r√©f√©rentiel
            obs_logger.info(
                "event=mixed_decision",
                event="mixed_decision",
                outcome="in_progress",
                chosen_path="exercise_types_override",
                exercise_types_count=len(exercise_types_override),
                **ctx
            )
            specs = _math_service.generate_math_exercise_specs_with_types(
                niveau=request.niveau,
                chapitre=request.chapitre,
                difficulte=request.difficulte,
                exercise_types=exercise_types_override,
                nb_exercices=1
            )
        else:
            # Mode legacy : utiliser le mapping par chapitre
            # V√©rifier si le chapitre a un pipeline TEMPLATE (ne doit jamais passer par MathGenerationService)
            if curriculum_chapter and hasattr(curriculum_chapter, 'pipeline') and curriculum_chapter.pipeline == "TEMPLATE":
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "TEMPLATE_PIPELINE_NO_DYNAMIC_EXERCISES",
                        "error": "template_pipeline_no_exercises",
                        "message": (
                            f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                            f"mais aucun exercice dynamique n'existe en DB pour ce chapitre."
                        ),
                        "chapter_code": request.code_officiel,
                        "pipeline": "TEMPLATE",
                        "hint": "Cr√©ez au moins un exercice dynamique pour ce chapitre ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                    }
                )
            
            specs = _math_service.generate_math_exercise_specs(
                niveau=request.niveau,
                chapitre=request.chapitre,
                difficulte=request.difficulte,
                nb_exercices=1
            )
        
        if not specs or len(specs) == 0:
            raise ValueError(f"Aucun exercice g√©n√©r√© pour {request.niveau} - {request.chapitre}")
        
        spec = specs[0]  # Prendre le premier exercice
        
        duration_ms = int((time.time() - request_start) * 1000)
        obs_logger.info(
            "event=request_complete",
            event="request_complete",
            outcome="success",
            duration_ms=duration_ms,
            chosen_path="legacy_static",
            exercise_type=str(spec.type_exercice) if spec.type_exercice else None,
            **ctx
        )
        logger.info(f"Exercice g√©n√©r√©: type={spec.type_exercice}, has_figure={spec.figure_geometrique is not None}")
        
    except HTTPException as e:
        # Propager les erreurs structur√©es d√©j√† construites
        duration_ms = int((time.time() - request_start) * 1000)
        obs_logger.error(
            "event=request_error",
            event="request_error",
            outcome="error",
            duration_ms=duration_ms,
            reason="http_exception",
            error_code=e.detail.get('error_code', None) if isinstance(e.detail, dict) else None,
            **ctx
        )
        raise
    except ValueError as e:
        duration_ms = int((time.time() - request_start) * 1000)
        obs_logger.error(
            "event=request_error",
            event="request_error",
            outcome="error",
            duration_ms=duration_ms,
            reason="validation_error",
            exception_type="ValueError",
            **ctx
        )
        logger.error(f"Validation g√©n√©ration exercice: {e}")
        raise HTTPException(
            status_code=422,
            detail={
                "error_code": "CHAPTER_OR_TYPE_INVALID",
                "error": "chapter_not_mapped",
                "message": str(e),
                "hint": "Ajoutez le chapitre dans MathGenerationService._get_exercise_types_for_chapter ou configurez un pipeline dynamique/statique avec des exercices disponibles."
            }
        )
    except Exception as e:
        duration_ms = int((time.time() - request_start) * 1000)
        obs_logger.error(
            "event=request_exception",
            event="request_exception",
            outcome="error",
            duration_ms=duration_ms,
            reason="generation_error",
            exception_type=type(e).__name__,
            **ctx,
            exc_info=True
        )
        logger.error(f"Erreur lors de la g√©n√©ration de l'exercice: {e}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail=f"Erreur lors de la g√©n√©ration de l'exercice : {str(e)}"
        )
    
    # ============================================================================
    # 4. G√âN√âRATION DU SVG (si figure g√©om√©trique pr√©sente OU figure_svg dans param√®tres)
    # ============================================================================
    
    svg_question = None
    svg_correction = None
    
    # D'abord v√©rifier si un SVG est directement fourni dans les param√®tres
    if spec.parametres and spec.parametres.get("figure_svg"):
        svg_question = spec.parametres.get("figure_svg")
        svg_correction = spec.parametres.get("figure_svg_correction", svg_question)
        logger.info(f"SVG fourni dans param√®tres: {len(svg_question or '')} chars")
    
    elif spec.figure_geometrique:
        try:
            # V1-BE-002-FIX: Utiliser l'instance globale (performance)
            result = _geom_service.render_figure_to_svg(spec.figure_geometrique)
            
            # G√©rer les deux formats de retour (dict ou string)
            if isinstance(result, dict):
                svg_question = result.get("figure_svg_question", result.get("figure_svg"))
                svg_correction = result.get("figure_svg_correction", result.get("figure_svg"))
            else:
                # Format string simple
                svg_question = result
                svg_correction = result
            
            logger.info(f"SVG g√©n√©r√©: question={len(svg_question or '')} chars, correction={len(svg_correction or '')} chars")
            
        except Exception as e:
            logger.error(f"Erreur lors de la g√©n√©ration du SVG: {e}", exc_info=True)
            # Continue sans SVG plut√¥t que de crasher
            svg_question = None
            svg_correction = None
    
    # ============================================================================
    # 5. CONSTRUCTION DE L'√âNONC√â ET DE LA SOLUTION HTML
    # ============================================================================
    
    # √ânonc√© - Priorit√© : enonce > expression > fallback intelligent
    enonce_text = spec.parametres.get("enonce", "") if spec.parametres else ""
    is_fallback = False
    
    if not enonce_text:
        # Fallback intelligent : g√©n√©rer un √©nonc√© p√©dagogique √† partir des param√®tres
        enonce_text = _build_fallback_enonce(spec, request.chapitre)
        is_fallback = True
    
    enonce_html = build_enonce_html(enonce_text, svg_question)
    
    # Solution
    etapes = spec.etapes_calculees or []
    resultat_final = spec.resultat_final or "Solution √† compl√©ter"
    solution_html = build_solution_html(etapes, resultat_final, svg_correction)
    
    # ============================================================================
    # 6. G√âN√âRATION DE L'ID ET DU PDF TOKEN
    # ============================================================================
    
    id_exercice = generate_exercise_id(request.niveau, request.chapitre)
    
    # Pour la v1, le pdf_token est simplement l'id_exercice
    # v2: g√©n√©ration de tokens temporaires avec expiration
    pdf_token = id_exercice
    
    # ============================================================================
    # 7. M√âTADONN√âES
    # ============================================================================
    
    # G√©n√©rer un code de g√©n√©rateur pour debug (ex: "6e_CALCUL_FRACTIONS")
    generator_code = f"{request.niveau}_{spec.type_exercice.name if spec.type_exercice else 'UNKNOWN'}"
    
    metadata = {
        "type_exercice": request.type_exercice,
        "difficulte": request.difficulte,
        "duree_estimee": 5,  # minutes (valeur par d√©faut)
        "points": 2.0,  # points de bar√®me (valeur par d√©faut)
        "domaine": curriculum_service.get_domaine_by_chapitre(request.niveau, request.chapitre),
        "has_figure": spec.figure_geometrique is not None or svg_question is not None,
        # Nouveaux champs pour debug/identification du g√©n√©rateur
        "is_fallback": is_fallback,
        "generator_code": generator_code,
        # Champs PREMIUM
        "is_premium": use_premium if 'use_premium' in locals() else False,
        "offer": request.offer,
        # P2.1 - Metadata de fallback premium
        "premium_available": len(filtered_premium_generators) > 0,
    }
    
    # P2.1 - Ajouter les g√©n√©rateurs filtr√©s si pr√©sents
    if filtered_premium_generators:
        metadata["filtered_premium_generators"] = filtered_premium_generators
        metadata["hint"] = "Certaines variantes premium ont √©t√© exclues (offre Pro requise)."
    
    # ============================================================================
    # 8. CONSTRUCTION DE LA R√âPONSE
    # ============================================================================
    
    response = ExerciseGenerateResponse(
        id_exercice=id_exercice,
        niveau=request.niveau,
        chapitre=request.chapitre,
        enonce_html=enonce_html,
        svg=svg_question,
        solution_html=solution_html,
        pdf_token=pdf_token,
        metadata=metadata
    )
    
    logger.info(f"Exercice g√©n√©r√© avec succ√®s: id={id_exercice}")
    
    return response


# Route de sant√© pour v√©rifier que le service fonctionne
@router.get(
    "/api/v1/exercises/health",
    summary="V√©rifier l'√©tat du service exercises",
    tags=["Health"]
)
async def health_check():
    """V√©rifie que le service exercises est op√©rationnel"""
    
    curriculum_info = curriculum_service.get_curriculum_info()
    
    return {
        "status": "healthy",
        "service": "exercises_v1",
        "curriculum": curriculum_info
    }

# ============================================================================
# 2. backend/services/exercise_persistence_service.py
# ============================================================================

"""
Service de persistance des exercices fig√©s en MongoDB.

G√®re les op√©rations CRUD sur les exercices pilotes (GM07, GM08, etc.).
Maintient la synchronisation entre MongoDB et les fichiers Python de donn√©es.

Architecture:
- MongoDB: Source de v√©rit√© pour les exercices
- Fichiers Python: G√©n√©r√©s automatiquement pour compatibilit√© avec les handlers
"""

import os
import logging
import hashlib
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timezone, timedelta
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import BaseModel, Field, validator

from backend.generators.factory import GeneratorFactory
from backend.services.template_renderer import get_template_variables
from backend.utils.difficulty_utils import (
    normalize_difficulty,
    coerce_to_supported_difficulty,
    get_all_canonical_difficulties,
    map_ui_difficulty_to_generator,  # P4.D HOTFIX
)
from backend.observability import get_request_context
from backend.observability.logger import get_logger as get_obs_logger
from fastapi import HTTPException
import re

logger = logging.getLogger(__name__)

# Collection MongoDB pour les exercices
EXERCISES_COLLECTION = "admin_exercises"

# Chemin vers le dossier data
DATA_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "data")


def _extract_placeholders(template_str: Optional[str]) -> set:
    """Extrait les placeholders {{variable}} d'un template."""
    if not template_str:
        return set()
    pattern = r'\{\{\s*(\w+)\s*\}\}'
    matches = re.findall(pattern, template_str)
    return set(matches)


# =============================================================================
# MOD√àLES PYDANTIC
# =============================================================================

class TemplateVariant(BaseModel):
    """
    Variant de template pour un exercice dynamique.
    """

    id: str = Field(..., description="Identifiant stable du variant (ex: 'v1', 'A', ...)")
    label: Optional[str] = Field(
        default=None, description="Label lisible du variant (optionnel)"
    )
    enonce_template_html: str = Field(
        ..., description="Template √©nonc√© avec {{variables}}"
    )
    solution_template_html: str = Field(
        ..., description="Template solution avec {{variables}}"
    )
    weight: int = Field(
        default=1,
        ge=1,
        description="Poids relatif du variant pour la s√©lection future",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="M√©tadonn√©es optionnelles (tags, notes p√©dagogiques, ...)",
    )


class ExerciseCreateRequest(BaseModel):
    """Mod√®le pour la cr√©ation d'un exercice"""

    title: Optional[str] = Field(
        default=None, description="Titre lisible (optionnel, surtout pour les exercices dynamiques)"
    )
    family: Optional[str] = Field(
        default=None,
        description="Famille (d√©pr√©ci√©): CONVERSION, COMPARAISON, PERIMETRE, PROBLEME, DUREES, etc.",
    )
    exercise_type: Optional[str] = Field(
        None, description="Type d'exercice (optionnel): LECTURE_HEURE, PLACER_AIGUILLES, etc."
    )
    difficulty: str = Field(..., description="Difficult√©: facile, moyen, difficile")
    offer: str = Field(default="free", description="Offre: free ou pro")
    # Flag dynamique EN PREMIER pour que les validateurs puissent le lire
    is_dynamic: bool = Field(default=False, description="Exercice dynamique (template)")
    # Exercices statiques
    enonce_html: Optional[str] = Field(
        default="", description="√ânonc√© en HTML pur (requis si non dynamique)"
    )
    solution_html: Optional[str] = Field(
        default="", description="Solution en HTML pur (requis si non dynamique)"
    )
    needs_svg: bool = Field(default=False, description="N√©cessite un SVG")
    variables: Optional[Dict[str, Any]] = Field(
        None, description="Variables pour le SVG (ex: {hour: 8, minute: 0})"
    )
    svg_enonce_brief: Optional[str] = Field(
        None, description="Description du SVG pour l'√©nonc√©"
    )
    svg_solution_brief: Optional[str] = Field(
        None, description="Description du SVG pour la solution"
    )
    # Exercices dynamiques
    generator_key: Optional[str] = Field(
        None, description="Cl√© du g√©n√©rateur (ex: THALES_V1)"
    )
    enonce_template_html: Optional[str] = Field(
        None, description="Template √©nonc√© avec {{variables}}"
    )
    solution_template_html: Optional[str] = Field(
        None, description="Template solution avec {{variables}}"
    )
    variables_schema: Optional[Dict[str, str]] = Field(
        None, description="Sch√©ma des variables"
    )
    template_variants: Optional[List[TemplateVariant]] = Field(
        default=None,
        description=(
            "Liste des variantes de templates pour les exercices dynamiques. "
            "Si renseign√©, devient la source de v√©rit√© pour le rendu dynamique."
        ),
    )

    @validator("enonce_html", always=True)
    def validate_enonce(cls, v, values):
        is_dynamic = values.get("is_dynamic", False)
        if not is_dynamic and not v:
            raise ValueError("enonce_html est requis pour les exercices statiques")
        return v or ""

    @validator("solution_html", always=True)
    def validate_solution(cls, v, values):
        is_dynamic = values.get("is_dynamic", False)
        if not is_dynamic and not v:
            raise ValueError("solution_html est requis pour les exercices statiques")
        return v or ""

    @validator("generator_key", always=True)
    def validate_generator(cls, v, values):
        is_dynamic = values.get("is_dynamic", False)
        if is_dynamic and not v:
            raise ValueError("generator_key est requis pour les exercices dynamiques")
        return v


class ExerciseUpdateRequest(BaseModel):
    """Mod√®le pour la mise √† jour d'un exercice"""
    title: Optional[str] = None
    family: Optional[str] = None  # D√©pr√©ci√©
    exercise_type: Optional[str] = None
    difficulty: Optional[str] = None
    offer: Optional[str] = None
    enonce_html: Optional[str] = None
    solution_html: Optional[str] = None
    needs_svg: Optional[bool] = None
    variables: Optional[Dict[str, Any]] = None
    svg_enonce_brief: Optional[str] = None
    svg_solution_brief: Optional[str] = None
    is_dynamic: Optional[bool] = None
    generator_key: Optional[str] = None
    enonce_template_html: Optional[str] = None
    solution_template_html: Optional[str] = None
    variables_schema: Optional[Dict[str, str]] = None
    template_variants: Optional[List[TemplateVariant]] = None


class ExerciseResponse(BaseModel):
    """R√©ponse pour un exercice"""
    id: int
    chapter_code: str
    title: Optional[str] = None
    family: Optional[str] = None  # D√©pr√©ci√©
    exercise_type: Optional[str] = None
    difficulty: str
    offer: str
    enonce_html: Optional[str] = None
    solution_html: Optional[str] = None
    needs_svg: bool
    variables: Optional[Dict[str, Any]] = None
    svg_enonce_brief: Optional[str] = None
    svg_solution_brief: Optional[str] = None
    is_dynamic: Optional[bool] = None
    generator_key: Optional[str] = None
    enonce_template_html: Optional[str] = None
    solution_template_html: Optional[str] = None
    template_variants: Optional[List[TemplateVariant]] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None


# =============================================================================
# SERVICE DE PERSISTANCE
# =============================================================================

class ExercisePersistenceService:
    """
    Service de persistance pour les exercices fig√©s.
    G√®re la synchronisation MongoDB <-> fichiers Python.
    """
    
    # Chapitres pilotes avec exercices fig√©s
    PILOT_CHAPTERS = ["6e_GM07", "6e_GM08", "6e_TESTS_DYN"]
    
    # Cache TTL pour get_stats (5 minutes)
    STATS_CACHE_TTL = timedelta(minutes=5)
    # Helper interne pour invalider le cache stats
    def _invalidate_stats_cache(self, chapter_code: str) -> None:
        cache_key = f"{chapter_code.upper().replace('-', '_')}_stats"
        if cache_key in self._stats_cache:
            self._stats_cache.pop(cache_key, None)
            logger.debug(f"[CACHE] Stats invalidated for {cache_key}")
    
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.collection = db[EXERCISES_COLLECTION]
        self._initialized = {}
        # Cache stats par instance (singleton, mais s√©curit√©)
        self._stats_cache: Dict[str, Tuple[Dict[str, Any], datetime]] = {}
    
    async def initialize_chapter(self, chapter_code: str) -> None:
        """
        Initialise la collection pour un chapitre si n√©cessaire.
        Charge les exercices depuis le fichier Python existant.
        
        Cache : Utilise self._initialized pour √©viter requ√™tes DB r√©p√©t√©es.
        """
        chapter_upper = chapter_code.upper().replace("-", "_")
        
        # Cache check AVANT requ√™te DB
        if chapter_upper in self._initialized:
            logger.debug(f"[CACHE HIT] Chapter {chapter_upper} d√©j√† initialis√©")
            return
        
        logger.info(f"[CACHE MISS] Initialisation {chapter_upper}")
        
        # Compter les exercices existants pour ce chapitre
        count = await self.collection.count_documents({"chapter_code": chapter_upper})
        
        # P0 - D√âSACTIVATION LEGACY : Ne plus charger depuis fichiers Python
        # Les exercices legacy ont √©t√© migr√©s en DB (migration P3.2)
        # DB est maintenant la source de v√©rit√© unique
        # if count == 0:
        #     await self._load_from_python_file(chapter_upper)
        #     count = await self.collection.count_documents({"chapter_code": chapter_upper})
        
        if count == 0:
            logger.info(f"[P0] Aucun exercice en DB pour {chapter_upper}. DB est la source unique (legacy d√©sactiv√©).")
        
        # Cr√©er les index (idempotent, mais co√ªteux ‚Üí √©viter si possible)
        try:
            await self.collection.create_index([("chapter_code", 1), ("id", 1)], unique=True)
            await self.collection.create_index("chapter_code")
            await self.collection.create_index("difficulty")
            await self.collection.create_index("offer")
        except Exception as e:
            # Index peut d√©j√† exister ‚Üí OK
            logger.debug(f"Index peut d√©j√† exister pour {chapter_upper}: {e}")
        
        self._initialized[chapter_upper] = True
        logger.info(f"Exercices service initialis√© pour {chapter_upper} avec {count} exercices")
    
    async def _load_from_python_file(self, chapter_code: str) -> None:
        """
        P0 - D√âSACTIV√â : Chargement depuis fichiers Python legacy
        
        Les exercices legacy ont √©t√© migr√©s en DB (migration P3.2).
        DB est maintenant la source de v√©rit√© unique.
        
        Cette m√©thode est conserv√©e pour r√©f√©rence mais ne fait plus rien.
        """
        logger.warning(
            f"[P0] _load_from_python_file d√©sactiv√© pour {chapter_code}. "
            f"Les exercices doivent √™tre en DB (migration P3.2 termin√©e)."
        )
        return
    
    async def _sync_to_python_file(self, chapter_code: str) -> None:
        """
        Synchronise les exercices MongoDB vers le fichier Python.
        G√©n√®re le code Python compatible avec les handlers existants.
        """
        exercises = await self.get_exercises(chapter_code)
        
        # D√©terminer le nom du fichier et de la variable
        file_mapping = {
            "6E_GM07": ("gm07_exercises.py", "GM07_EXERCISES", "Dur√©es et lecture de l'heure"),
            "6E_GM08": ("gm08_exercises.py", "GM08_EXERCISES", "Grandeurs et Mesures (Longueurs, P√©rim√®tres)"),
        }
        
        info = file_mapping.get(chapter_code)
        if not info:
            logger.warning(f"Pas de mapping fichier pour {chapter_code}")
            return
        
        filename, var_name, description = info
        filepath = os.path.join(DATA_DIR, filename)
        
        # G√©n√©rer le contenu Python
        content = self._generate_python_file(chapter_code, var_name, description, exercises)
        
        # √âcrire le fichier
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)
        
        logger.info(f"Fichier Python synchronis√©: {filepath} ({len(exercises)} exercices)")
    
    def _generate_python_file(self, chapter_code: str, var_name: str, description: str, exercises: List[Dict]) -> str:
        """G√©n√®re le contenu du fichier Python pour les exercices"""
        code = chapter_code.split("_")[1]  # GM07, GM08
        
        header = f'''"""
{code} - Exercices fig√©s : {description}
{'=' * (len(code) + len(description) + 25)}

Chapitre pilote avec {len(exercises)} exercices valid√©s.
- FREE: ids 1-10
- PREMIUM (PRO): ids 11-20

Ce fichier est la SOURCE UNIQUE pour {code}.
Aucune g√©n√©ration al√©atoire - exercices fig√©s et valid√©s.

IMPORTANT: Tout le contenu est en HTML PUR.
- Pas de Markdown (**texte**)
- Pas de LaTeX ($...$)
- Utiliser <strong>, <em>, √ó, √∑, etc.

‚ö†Ô∏è FICHIER G√âN√âR√â AUTOMATIQUEMENT PAR L'ADMIN
   Ne pas modifier manuellement - utiliser /admin/curriculum
"""

from typing import List, Dict, Any, Optional
import random


# =============================================================================
# {len(exercises)} EXERCICES {code} VALID√âS - HTML PUR (sans Markdown ni LaTeX)
# =============================================================================

{var_name}: List[Dict[str, Any]] = [
'''
        
        # Ajouter chaque exercice
        for ex in exercises:
            # Construire les champs optionnels
            exercise_type_str = f'"{ex["exercise_type"]}"' if ex.get('exercise_type') else 'None'
            variables_str = repr(ex.get('variables')) if ex.get('variables') else 'None'
            svg_enonce_brief_str = f'"{ex["svg_enonce_brief"]}"' if ex.get('svg_enonce_brief') else 'None'
            svg_solution_brief_str = f'"{ex["svg_solution_brief"]}"' if ex.get('svg_solution_brief') else 'None'
            
            content = f'''    {{
        "id": {ex['id']},
        "family": "{ex['family']}",
        "difficulty": "{ex['difficulty']}",
        "offer": "{ex['offer']}",
        "variables": {variables_str},
        "enonce_html": """{ex['enonce_html']}""",
        "solution_html": """{ex['solution_html']}""",
        "needs_svg": {str(ex.get('needs_svg', False))},
        "exercise_type": {exercise_type_str},
        "svg_enonce_brief": {svg_enonce_brief_str},
        "svg_solution_brief": {svg_solution_brief_str}
    }},
'''
            header += content
        
        header += ''']


# =============================================================================
# FONCTIONS D'ACC√àS AUX EXERCICES (Compatible avec handlers)
# =============================================================================

'''
        
        # Ajouter les fonctions utilitaires
        header += f'''
def get_{code.lower()}_exercises(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Filtre les exercices selon les crit√®res.
    
    Args:
        offer: "free" ou "pro" (None = tous selon r√®gles)
        difficulty: "facile", "moyen", "difficile" (None = tous)
    
    Returns:
        Liste d'exercices filtr√©s
    """
    exercises = {var_name}
    
    # Filtrer par offer
    if offer:
        offer = offer.lower()
        if offer == "free":
            exercises = [ex for ex in exercises if ex["offer"] == "free"]
        elif offer == "pro":
            pass  # PRO voit tout
    else:
        # Par d√©faut, FREE ne voit que free
        exercises = [ex for ex in exercises if ex["offer"] == "free"]
    
    # Filtrer par difficult√©
    if difficulty:
        difficulty = difficulty.lower()
        exercises = [ex for ex in exercises if ex["difficulty"] == difficulty]
    
    return exercises


def get_random_{code.lower()}_exercise(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None,
    seed: Optional[int] = None
) -> Optional[Dict[str, Any]]:
    """
    S√©lectionne UN exercice al√©atoire.
    
    Args:
        offer: "free" ou "pro" (None = free par d√©faut)
        difficulty: "facile", "moyen", "difficile" (None = tous)
        seed: graine pour reproductibilit√© (optionnel)
    
    Returns:
        Un exercice al√©atoire ou None si aucun disponible
    """
    available = get_{code.lower()}_exercises(offer=offer, difficulty=difficulty)
    
    if not available:
        return None
    
    if seed is not None:
        random.seed(seed)
    
    return random.choice(available)


def get_{code.lower()}_batch(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None,
    count: int = 1,
    seed: Optional[int] = None
) -> tuple:
    """
    G√©n√®re un batch d'exercices SANS DOUBLONS.
    
    Args:
        offer: "free" ou "pro"
        difficulty: filtre optionnel
        count: nombre d'exercices demand√©s
        seed: graine pour reproductibilit√©
    
    Returns:
        Tuple (exercices: List, batch_metadata: Dict)
    """
    available = get_{code.lower()}_exercises(offer=offer, difficulty=difficulty)
    pool_size = len(available)
    
    batch_meta = {{
        "requested": count,
        "available": pool_size,
        "returned": 0,
        "filters": {{
            "offer": offer or "free",
            "difficulty": difficulty
        }}
    }}
    
    if pool_size == 0:
        batch_meta["warning"] = f"Aucun exercice disponible pour les filtres s√©lectionn√©s."
        return [], batch_meta
    
    # M√©langer avec seed pour reproductibilit√©
    if seed is not None:
        random.seed(seed)
    
    shuffled = available.copy()
    random.shuffle(shuffled)
    
    # Prendre au maximum ce qui est disponible
    actual_count = min(count, pool_size)
    selected = shuffled[:actual_count]
    
    batch_meta["returned"] = actual_count
    
    if actual_count < count:
        batch_meta["warning"] = f"Seulement {{pool_size}} exercices disponibles pour les filtres s√©lectionn√©s ({{count}} demand√©s)."
    
    return selected, batch_meta


def get_exercise_by_seed_index(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None,
    seed: Optional[int] = None
) -> Optional[Dict[str, Any]]:
    """
    S√©lectionne UN exercice de mani√®re d√©terministe.
    """
    available = get_{code.lower()}_exercises(offer=offer, difficulty=difficulty)
    
    if not available:
        return None
    
    if seed is not None:
        random.seed(seed)
        index = random.randint(0, len(available) - 1)
    else:
        index = random.randint(0, len(available) - 1)
    
    return available[index]


def get_{code.lower()}_stats() -> Dict[str, Any]:
    """Statistiques sur les exercices"""
    exercises = {var_name}
    
    stats = {{
        "total": len(exercises),
        "by_offer": {{"free": 0, "pro": 0}},
        "by_difficulty": {{"facile": 0, "moyen": 0, "difficile": 0}},
        "by_family": {{}}
    }}
    
    for ex in exercises:
        stats["by_offer"][ex["offer"]] = stats["by_offer"].get(ex["offer"], 0) + 1
        stats["by_difficulty"][ex["difficulty"]] = stats["by_difficulty"].get(ex["difficulty"], 0) + 1
        
        family = ex.get("family")
        if family:
            stats["by_family"][family] = stats["by_family"].get(family, 0) + 1
    
    return stats
'''
        
        return header
    
    # =========================================================================
    # CRUD OPERATIONS
    # =========================================================================
    
    async def get_exercises(
        self,
        chapter_code: str,
        offer: Optional[str] = None,
        difficulty: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """R√©cup√®re les exercices d'un chapitre avec filtres optionnels"""
        from logger import get_logger
        diag_logger = get_logger()
        
        chapter_upper = chapter_code.upper().replace("-", "_")
        await self.initialize_chapter(chapter_upper)
        
        query = {"chapter_code": chapter_upper}
        
        if offer:
            query["offer"] = offer.lower()
        if difficulty:
            query["difficulty"] = difficulty.lower()
        
        # P0 - DIAGNOSTIC : Log de la requ√™te MongoDB exacte
        diag_logger.info(
            f"[DIAG_6E_G07] MongoDB query: collection='{self.collection.name}', "
            f"query={query}"
        )
        
        exercises = await self.collection.find(
            query,
            {"_id": 0}
        ).sort("id", 1).to_list(1000)  # Augmenter la limite pour les chapitres avec beaucoup d'exercices
        
        diag_logger.info(
            f"[DIAG_6E_G07] MongoDB result: {len(exercises)} exercices trouv√©s"
        )
        
        return exercises
    
    async def get_exercise_by_id(self, chapter_code: str, exercise_id: int) -> Optional[Dict[str, Any]]:
        """R√©cup√®re un exercice par son ID"""
        chapter_upper = chapter_code.upper().replace("-", "_")
        await self.initialize_chapter(chapter_upper)
        
        exercise = await self.collection.find_one(
            {"chapter_code": chapter_upper, "id": exercise_id},
            {"_id": 0}
        )
        
        return exercise
    
    async def create_exercise(self, chapter_code: str, request: ExerciseCreateRequest) -> Dict[str, Any]:
        """
        Cr√©e un nouvel exercice.
        L'ID est automatiquement assign√© (max_id + 1).
        """
        chapter_upper = chapter_code.upper().replace("-", "_")
        await self.initialize_chapter(chapter_upper)
        
        # Valider les donn√©es
        self._validate_exercise_data(request)
        
        # Validation des placeholders pour exercices dynamiques
        if request.is_dynamic and request.generator_key:
            self._validate_template_placeholders(
                generator_key=request.generator_key,
                enonce_template_html=request.enonce_template_html,
                solution_template_html=request.solution_template_html,
                template_variants=request.template_variants,
                exercise_params=request.variables or {}
            )
        
        # D√©terminer exercise_type pour les dynamiques (source de v√©rit√© GeneratorFactory)
        exercise_type_resolved = request.exercise_type.upper() if request.exercise_type else None
        if request.is_dynamic and request.generator_key:
            gen_type = GeneratorFactory.get_exercise_type(request.generator_key)
            if not gen_type:
                raise ValueError(f"generator_key inconnu ou sans exercise_type: {request.generator_key}")
            # Verrou collision : si un exercise_type est fourni et diff√®re, on refuse
            if exercise_type_resolved and exercise_type_resolved != gen_type:
                raise ValueError(
                    f"collision exercise_type/generator_key: exercise_type='{exercise_type_resolved}' "
                    f"mais {request.generator_key} correspond √† '{gen_type}'. "
                    "Retirez l'exercise_type manuel ou choisissez le generator_key ad√©quat."
                )
            exercise_type_resolved = gen_type
        
        # Trouver le prochain ID
        max_doc = await self.collection.find_one(
            {"chapter_code": chapter_upper},
            sort=[("id", -1)]
        )
        next_id = (max_doc["id"] + 1) if max_doc else 1
        
        # P0 - Calculer exercise_uid pour √©viter l'erreur E11000 (duplicate key sur null)
        # Pour les exercices dynamiques, utiliser les templates
        # Pour les exercices statiques, utiliser l'√©nonc√©/solution HTML
        if request.is_dynamic:
            # Exercice dynamique : utiliser les templates
            enonce_content = request.enonce_template_html or ""
            solution_content = request.solution_template_html or ""
        else:
            # Exercice statique : utiliser l'√©nonc√©/solution HTML
            enonce_content = request.enonce_html or ""
            solution_content = request.solution_html or ""
        
        # Calculer l'UID stable (m√™me logique que migration)
        normalized_enonce = enonce_content.strip().lower()
        normalized_solution = solution_content.strip().lower()
        unique_string = f"{chapter_upper}|{normalized_enonce}|{normalized_solution}|{request.difficulty.lower()}"
        exercise_uid = hashlib.sha256(unique_string.encode('utf-8')).hexdigest()
        
        # V√©rifier si un exercice avec le m√™me UID existe d√©j√†
        existing = await self.collection.find_one({"exercise_uid": exercise_uid})
        if existing:
            raise ValueError(
                f"Un exercice identique existe d√©j√† (UID={exercise_uid[:8]}...). "
                f"Modifiez l√©g√®rement l'√©nonc√© ou la solution pour cr√©er un nouvel exercice."
            )
        
        # Cr√©er le document
        doc = {
            "chapter_code": chapter_upper,
            "id": next_id,
            "exercise_uid": exercise_uid,  # P0 - UID calcul√© pour √©viter duplicate key
            "title": request.title,
            "family": request.family.upper() if request.family else None,
            "exercise_type": exercise_type_resolved,
            "difficulty": request.difficulty.lower(),
            "offer": request.offer.lower(),
            "enonce_html": request.enonce_html or "",
            "solution_html": request.solution_html or "",
            "needs_svg": request.needs_svg,
            "variables": request.variables,
            "svg_enonce_brief": request.svg_enonce_brief,
            "svg_solution_brief": request.svg_solution_brief,
            # Champs dynamiques
            "is_dynamic": request.is_dynamic,
            "generator_key": request.generator_key,
            "enonce_template_html": request.enonce_template_html,
            "solution_template_html": request.solution_template_html,
            "variables_schema": request.variables_schema,
            "template_variants": [
                variant.dict() for variant in (request.template_variants or [])
            ] or None,
            "created_at": datetime.now(timezone.utc),
            "updated_at": datetime.now(timezone.utc)
        }
        
        await self.collection.insert_one(doc)
        if request.family:
            logger.warning(f"[DEPRECATED] Champ family utilis√© lors de la cr√©ation (chapter={chapter_upper}, family={request.family.upper()}). Migrer vers exercise_type.")
        
        # Synchroniser avec le fichier Python (seulement pour GM07/GM08)
        if chapter_upper in ["6E_GM07", "6E_GM08"]:
            await self._sync_to_python_file(chapter_upper)
            await self._reload_handler(chapter_upper)
        
        # Invalidate stats cache
        self._invalidate_stats_cache(chapter_upper)
        # Invalidate catalog cache (6e)
        try:
            from curriculum.loader import invalidate_catalog_cache
            invalidate_catalog_cache("6e")
        except Exception as e:
            logger.warning(f"[CATALOG] Impossible d'invalider le cache catalogue: {e}")
        
        logger.info(f"Exercice cr√©√©: {chapter_upper} #{next_id} (dynamic={request.is_dynamic})")
        
        del doc["_id"]
        return doc
    
    async def update_exercise(
        self,
        chapter_code: str,
        exercise_id: int,
        request: ExerciseUpdateRequest
    ) -> Dict[str, Any]:
        """Met √† jour un exercice existant"""
        chapter_upper = chapter_code.upper().replace("-", "_")
        await self.initialize_chapter(chapter_upper)
        
        # V√©rifier l'existence
        existing = await self.collection.find_one({
            "chapter_code": chapter_upper,
            "id": exercise_id
        })
        
        if not existing:
            raise ValueError(f"Exercice #{exercise_id} non trouv√© dans {chapter_upper}")
        
        # Construire les champs √† mettre √† jour
        update_data = {}
        
        if request.family is not None:
            update_data["family"] = request.family.upper() if request.family else None
            if request.family:
                logger.warning(f"[DEPRECATED] Champ family utilis√© en update (chapter={chapter_upper}, family={request.family.upper()}). Migrer vers exercise_type.")
        if request.exercise_type is not None:
            update_data["exercise_type"] = request.exercise_type.upper() if request.exercise_type else None
        if request.difficulty is not None:
            update_data["difficulty"] = request.difficulty.lower()
        if request.offer is not None:
            update_data["offer"] = request.offer.lower()
        if request.enonce_html is not None:
            update_data["enonce_html"] = request.enonce_html
        if request.solution_html is not None:
            update_data["solution_html"] = request.solution_html
        if request.needs_svg is not None:
            update_data["needs_svg"] = request.needs_svg
        if request.title is not None:
            update_data["title"] = request.title
        # Champs dynamiques
        if request.enonce_template_html is not None:
            update_data["enonce_template_html"] = request.enonce_template_html
        if request.solution_template_html is not None:
            update_data["solution_template_html"] = request.solution_template_html
        if request.is_dynamic is not None:
            update_data["is_dynamic"] = request.is_dynamic
        if request.generator_key is not None:
            update_data["generator_key"] = request.generator_key
        
        # Validation des placeholders pour exercices dynamiques (si template ou generator_key modifi√©)
        is_dynamic = update_data.get("is_dynamic", existing.get("is_dynamic", False))
        generator_key = update_data.get("generator_key", existing.get("generator_key"))
        enonce_template = update_data.get("enonce_template_html", existing.get("enonce_template_html"))
        solution_template = update_data.get("solution_template_html", existing.get("solution_template_html"))
        template_variants = update_data.get("template_variants", existing.get("template_variants"))
        exercise_params = update_data.get("variables", existing.get("variables", {}))
        
        if is_dynamic and generator_key and (enonce_template or solution_template or template_variants):
            self._validate_template_placeholders(
                generator_key=generator_key,
                enonce_template_html=enonce_template,
                solution_template_html=solution_template,
                template_variants=template_variants,
                exercise_params=exercise_params or {}
            )
        
        # Sauvegarder variables m√™me si c'est un objet vide (pour permettre de r√©initialiser)
        # Note: request.variables peut √™tre None (non fourni), {} (vide), ou un dict avec des valeurs
        if hasattr(request, 'variables') and request.variables is not None:
            # Si c'est un objet vide {}, on le sauvegarde quand m√™me (pour r√©initialiser les param√®tres)
            update_data["variables"] = request.variables if isinstance(request.variables, dict) else {}
            logger.debug(f"[UPDATE] Variables mises √† jour: {update_data['variables']}")
        if request.variables_schema is not None:
            update_data["variables_schema"] = request.variables_schema
        if request.template_variants is not None:
            update_data["template_variants"] = [
                variant.dict() if hasattr(variant, 'dict') else variant
                for variant in request.template_variants
            ] if request.template_variants else None
        # Synchroniser exercise_type si dynamique et generator_key pr√©sent (nouveau ou existant)
        if (update_data.get("is_dynamic", existing.get("is_dynamic")) and
            update_data.get("generator_key", existing.get("generator_key"))):
            gen_key = update_data.get("generator_key", existing.get("generator_key"))
            gen_type = GeneratorFactory.get_exercise_type(gen_key)
            if not gen_type:
                raise ValueError(f"generator_key inconnu ou sans exercise_type: {gen_key}")
            # Verrou collision : si un exercise_type est fourni et diff√®re, on refuse
            if request.exercise_type is not None:
                requested_type = request.exercise_type.upper() if request.exercise_type else None
                if requested_type and requested_type != gen_type:
                    raise ValueError(
                        f"collision exercise_type/generator_key: exercise_type='{requested_type}' "
                        f"mais {gen_key} correspond √† '{gen_type}'. "
                        "Retirez l'exercise_type manuel ou choisissez le generator_key ad√©quat."
                    )
            update_data["exercise_type"] = gen_type
        
        if not update_data:
            del existing["_id"]
            return existing
        
        # P0 - Recalculer exercise_uid si le contenu a chang√©
        # (pour √©viter les doublons et maintenir la coh√©rence)
        content_changed = any(key in update_data for key in [
            "enonce_html", "solution_html", "enonce_template_html", 
            "solution_template_html", "difficulty", "is_dynamic"
        ])
        
        if content_changed or not existing.get("exercise_uid"):
            # Recalculer l'UID avec les nouvelles valeurs
            is_dynamic = update_data.get("is_dynamic", existing.get("is_dynamic", False))
            if is_dynamic:
                enonce_content = update_data.get("enonce_template_html", existing.get("enonce_template_html", "")) or ""
                solution_content = update_data.get("solution_template_html", existing.get("solution_template_html", "")) or ""
            else:
                enonce_content = update_data.get("enonce_html", existing.get("enonce_html", "")) or ""
                solution_content = update_data.get("solution_html", existing.get("solution_html", "")) or ""
            
            normalized_enonce = enonce_content.strip().lower()
            normalized_solution = solution_content.strip().lower()
            difficulty = update_data.get("difficulty", existing.get("difficulty", "moyen")).lower()
            unique_string = f"{chapter_upper}|{normalized_enonce}|{normalized_solution}|{difficulty}"
            new_exercise_uid = hashlib.sha256(unique_string.encode('utf-8')).hexdigest()
            
            # V√©rifier si le nouvel UID existe d√©j√† (sauf pour cet exercice)
            existing_uid = await self.collection.find_one({
                "exercise_uid": new_exercise_uid,
                "_id": {"$ne": existing.get("_id")}
            })
            if existing_uid:
                logger.warning(
                    f"[UPDATE] UID collision d√©tect√©e pour exercice #{exercise_id} "
                    f"(nouvel UID={new_exercise_uid[:8]}... existe d√©j√†). "
                    "L'UID ne sera pas mis √† jour pour √©viter les doublons."
                )
            else:
                update_data["exercise_uid"] = new_exercise_uid
        
        update_data["updated_at"] = datetime.now(timezone.utc)
        
        await self.collection.update_one(
            {"chapter_code": chapter_upper, "id": exercise_id},
            {"$set": update_data}
        )
        
        # Synchroniser avec le fichier Python
        await self._sync_to_python_file(chapter_upper)
        
        # Recharger le handler
        await self._reload_handler(chapter_upper)
        
        # Invalidate stats cache
        self._invalidate_stats_cache(chapter_upper)
        
        # Invalider le cache catalogue pour refl√©ter l'ajout/modif
        try:
            from curriculum.loader import invalidate_catalog_cache
            invalidate_catalog_cache("6e")
        except Exception as e:
            logger.warning(f"[CATALOG] Impossible d'invalider le cache catalogue: {e}")
        
        logger.info(f"Exercice mis √† jour: {chapter_upper} #{exercise_id}")
        
        # R√©cup√©rer l'exercice mis √† jour
        updated = await self.collection.find_one(
            {"chapter_code": chapter_upper, "id": exercise_id},
            {"_id": 0}
        )
        
        return updated
    
    async def delete_exercise(self, chapter_code: str, exercise_id: int) -> bool:
        """Supprime un exercice"""
        chapter_upper = chapter_code.upper().replace("-", "_")
        await self.initialize_chapter(chapter_upper)
        
        # V√©rifier l'existence
        existing = await self.collection.find_one({
            "chapter_code": chapter_upper,
            "id": exercise_id
        })
        
        if not existing:
            raise ValueError(f"Exercice #{exercise_id} non trouv√© dans {chapter_upper}")
        
        result = await self.collection.delete_one({
            "chapter_code": chapter_upper,
            "id": exercise_id
        })
        
        if result.deleted_count > 0:
            # Synchroniser avec le fichier Python
            await self._sync_to_python_file(chapter_upper)
            
            # Recharger le handler
            await self._reload_handler(chapter_upper)
            
            # Invalidate stats cache
            self._invalidate_stats_cache(chapter_upper)
            
            # Invalider le cache catalogue (6e) pour refl√©ter la suppression
            try:
                from curriculum.loader import invalidate_catalog_cache
                invalidate_catalog_cache("6e")
            except Exception as e:
                logger.warning(f"[CATALOG] Impossible d'invalider le cache catalogue: {e}")
            
            logger.info(f"Exercice supprim√©: {chapter_upper} #{exercise_id}")
            return True
        
        return False
    
    async def find_exercise_by_id_anywhere(self, exercise_id: int) -> Optional[Dict[str, Any]]:
        """Trouve un exercice par son ID dans n'importe quel chapitre"""
        exercise = await self.collection.find_one(
            {"id": exercise_id},
            {"_id": 0}
        )
        return exercise
    
    async def get_stats(self, chapter_code: str) -> Dict[str, Any]:
        """
        Statistiques sur les exercices d'un chapitre.
        
        Cache TTL 5 minutes pour √©viter agr√©gations MongoDB r√©p√©t√©es.
        """
        chapter_upper = chapter_code.upper().replace("-", "_")
        
        # Check cache TTL
        cache_key = f"{chapter_upper}_stats"
        now = datetime.now(timezone.utc)
        
        if cache_key in self._stats_cache:
            cached_stats, cached_time = self._stats_cache[cache_key]
            if now - cached_time < self.STATS_CACHE_TTL:
                logger.debug(f"[CACHE HIT] Stats pour {chapter_upper}")
                return cached_stats
        
        logger.info(f"[CACHE MISS] Calcul stats pour {chapter_upper}")
        
        await self.initialize_chapter(chapter_upper)
        
        total = await self.collection.count_documents({"chapter_code": chapter_upper})
        
        # Agr√©gations MongoDB (co√ªteuses)
        by_offer = {}
        by_difficulty = {}
        by_family = {}
        
        offer_agg = await self.collection.aggregate([
            {"$match": {"chapter_code": chapter_upper}},
            {"$group": {"_id": "$offer", "count": {"$sum": 1}}}
        ]).to_list(10)
        
        for item in offer_agg:
            by_offer[item["_id"]] = item["count"]
        
        diff_agg = await self.collection.aggregate([
            {"$match": {"chapter_code": chapter_upper}},
            {"$group": {"_id": "$difficulty", "count": {"$sum": 1}}}
        ]).to_list(10)
        
        for item in diff_agg:
            by_difficulty[item["_id"]] = item["count"]
        
        family_agg = await self.collection.aggregate([
            {"$match": {"chapter_code": chapter_upper}},
            {"$group": {"_id": "$family", "count": {"$sum": 1}}}
        ]).to_list(20)
        
        for item in family_agg:
            by_family[item["_id"]] = item["count"]
        
        stats = {
            "chapter_code": chapter_upper,
            "total": total,
            "by_offer": by_offer,
            "by_difficulty": by_difficulty,
            "by_family": by_family
        }
        
        # Mettre en cache
        self._stats_cache[cache_key] = (stats, now)
        
        return stats
    
    def _validate_exercise_data(self, request: ExerciseCreateRequest) -> None:
        """Valide les donn√©es d'un exercice"""
        # V√©rifier la difficult√©
        if request.difficulty.lower() not in ["facile", "moyen", "difficile"]:
            raise ValueError(f"Difficult√© invalide: {request.difficulty}")
        
        # V√©rifier l'offer
        if request.offer.lower() not in ["free", "pro"]:
            raise ValueError(f"Offer invalide: {request.offer}")
        
        # Validation sp√©cifique selon le type (dynamique ou statique)
        if request.is_dynamic:
            # Exercice dynamique - v√©rifier le g√©n√©rateur
            if not request.generator_key:
                raise ValueError("generator_key est requis pour les exercices dynamiques")

            # Un exercice dynamique doit avoir AU MOINS un template :
            # - soit en mode legacy (enonce_template_html + solution_template_html),
            # - soit via une ou plusieurs TemplateVariant.
            has_legacy_templates = bool(
                request.enonce_template_html
                and request.enonce_template_html.strip()
                and request.solution_template_html
                and request.solution_template_html.strip()
            )
            has_variants = bool(request.template_variants and len(request.template_variants) > 0)

            if not has_legacy_templates and not has_variants:
                raise ValueError(
                    "Au moins un template (legacy ou variant) est requis pour un exercice dynamique"
                )

            # Si des variants sont fournis, v√©rifier qu'ils sont complets et coh√©rents
            if request.template_variants:
                for idx, variant in enumerate(request.template_variants):
                    # id non vide
                    if not variant.id or not str(variant.id).strip():
                        raise ValueError(
                            f"Le variant #{idx + 1} doit avoir un id non vide"
                        )

                    # weight >= 1 (double garde-fou en plus de la contrainte Pydantic)
                    if variant.weight is None or variant.weight < 1:
                        raise ValueError(
                            f"Le variant #{idx + 1} ({variant.id}) doit avoir un weight >= 1"
                        )

                    # templates non vides
                    if (
                        not variant.enonce_template_html
                        or not variant.enonce_template_html.strip()
                    ):
                        raise ValueError(
                            f"Le variant #{idx + 1} ({variant.id}) doit avoir un template √©nonc√© non vide"
                        )
                    if (
                        not variant.solution_template_html
                        or not variant.solution_template_html.strip()
                    ):
                        raise ValueError(
                            f"Le variant #{idx + 1} ({variant.id}) doit avoir un template solution non vide"
                        )
        else:
            # Exercice statique - v√©rifier le HTML
            if not request.enonce_html or not request.enonce_html.strip():
                raise ValueError("L'√©nonc√© ne peut pas √™tre vide")
            
            if not request.solution_html or not request.solution_html.strip():
                raise ValueError("La solution ne peut pas √™tre vide")
            
            # V√©rifier pas de LaTeX
            if "$" in request.enonce_html or "$" in request.solution_html:
                raise ValueError("Le contenu ne doit pas contenir de LaTeX ($). Utilisez du HTML pur.")
    
    def _validate_template_placeholders(
        self,
        generator_key: str,
        enonce_template_html: Optional[str],
        solution_template_html: Optional[str],
        template_variants: Optional[List[Any]],  # Peut √™tre List[TemplateVariant] ou List[Dict]
        exercise_params: Dict[str, Any]
    ) -> None:
        """
        Valide que tous les placeholders des templates peuvent √™tre r√©solus par le g√©n√©rateur.
        Teste pour chaque difficult√© (facile, moyen, difficile).
        
        L√®ve HTTPException(422) avec error_code="ADMIN_TEMPLATE_MISMATCH" si mismatch.
        """
        # Extraire tous les placeholders attendus
        placeholders_expected = set()
        
        # Templates principaux
        if enonce_template_html:
            placeholders_expected.update(_extract_placeholders(enonce_template_html))
        if solution_template_html:
            placeholders_expected.update(_extract_placeholders(solution_template_html))
        
        # Templates variants
        if template_variants:
            for variant in template_variants:
                # G√©rer les objets Pydantic TemplateVariant ou les dictionnaires
                if hasattr(variant, 'dict'):
                    # Objet Pydantic TemplateVariant
                    variant_dict = variant.dict()
                elif isinstance(variant, dict):
                    # Dictionnaire d√©j√†
                    variant_dict = variant
                else:
                    # Type inattendu, skip
                    logger.warning(f"Type de variant inattendu: {type(variant)}, skip")
                    continue
                
                if variant_dict.get("enonce_template_html"):
                    placeholders_expected.update(_extract_placeholders(variant_dict["enonce_template_html"]))
                if variant_dict.get("solution_template_html"):
                    placeholders_expected.update(_extract_placeholders(variant_dict["solution_template_html"]))
        
        if not placeholders_expected:
            # Pas de placeholders √† valider
            return
        
        # R√©cup√©rer le g√©n√©rateur
        gen_class = GeneratorFactory.get(generator_key)
        if not gen_class:
            # Le g√©n√©rateur sera valid√© ailleurs, on skip ici
            return
        
        # P4.D HOTFIX - Tester pour chaque difficult√© canonique avec mapping UI -> g√©n√©rateur
        difficulties_to_test = ["facile", "moyen", "difficile"]
        all_mismatches = []
        obs_logger = get_obs_logger('EXERCISE_PERSISTENCE')
        ctx = get_request_context()
        ctx.update({'generator_key': generator_key})
        
        for requested_difficulty in difficulties_to_test:
            # P4.D HOTFIX - Mapper la difficult√© UI vers la difficult√© r√©elle du g√©n√©rateur
            generator_difficulty = map_ui_difficulty_to_generator(
                generator_key,
                requested_difficulty,
                obs_logger
            )
            
            try:
                
                # Pr√©parer les param√®tres de g√©n√©ration avec la difficult√© mapp√©e
                gen_params = exercise_params.copy()
                gen_params["difficulty"] = generator_difficulty
                
                # G√©n√©rer un exercice de test
                generator = gen_class(seed=42)  # Seed fixe pour reproductibilit√©
                result = generator.generate(gen_params)
                
                # R√©cup√©rer les cl√©s fournies
                keys_provided = set(result.get("variables", {}).keys())
                
                # Comparer
                missing = sorted(placeholders_expected - keys_provided)
                extra = sorted(keys_provided - placeholders_expected)
                
                if missing:
                    all_mismatches.append({
                        "difficulty": requested_difficulty,
                        "difficulty_used": generator_difficulty,  # P4.D HOTFIX - Difficult√© r√©ellement utilis√©e
                        "missing": missing,
                        "extra": extra,
                        "placeholders_expected": sorted(placeholders_expected),
                        "keys_provided": sorted(keys_provided)
                    })
            except ValueError as e:
                # P4.D HOTFIX - Distinguer les erreurs de difficult√© invalide des autres erreurs
                error_msg = str(e)
                if "difficult√©" in error_msg.lower() or "difficulty" in error_msg.lower() or "INVALID_DIFFICULTY" in error_msg:
                    # Erreur de difficult√© invalide - ne pas consid√©rer comme mismatch
                    logger.warning(
                        f"[GENERATOR_INVALID_DIFFICULTY] Validation placeholder pour {generator_key} "
                        f"(ui={requested_difficulty}, generator={generator_difficulty}): {error_msg}"
                    )
                    # Ne pas ajouter √† all_mismatches - c'est une erreur de difficult√©, pas de template
                    continue
                else:
                    # Autre erreur - consid√©rer comme mismatch
                    logger.warning(f"Erreur lors de la validation placeholder pour {generator_key} (ui={requested_difficulty}, generator={generator_difficulty}): {e}")
                    all_mismatches.append({
                        "difficulty": requested_difficulty,
                        "difficulty_used": generator_difficulty,
                        "missing": sorted(placeholders_expected),
                        "extra": [],
                        "error": str(e)
                    })
            except Exception as e:
                # Si la g√©n√©ration √©choue pour une autre raison, on consid√®re comme mismatch
                logger.warning(f"Erreur lors de la validation placeholder pour {generator_key} (ui={requested_difficulty}, generator={generator_difficulty}): {e}")
                all_mismatches.append({
                    "difficulty": requested_difficulty,
                    "difficulty_used": generator_difficulty,
                    "missing": sorted(placeholders_expected),
                    "extra": [],
                    "error": str(e)
                })
        
        # Si des mismatches sont d√©tect√©s, lever une erreur
        if all_mismatches:
            # Construire le message d'erreur
            missing_summary = set()
            for mismatch in all_mismatches:
                missing_summary.update(mismatch["missing"])
            
            missing_list = ", ".join(sorted(missing_summary)[:5])
            if len(missing_summary) > 5:
                missing_list += f" et {len(missing_summary) - 5} autre(s)"
            
            hint = (
                f"Les placeholders suivants ne peuvent pas √™tre r√©solus par le g√©n√©rateur '{generator_key}': {missing_list}. "
                f"V√©rifiez que le g√©n√©rateur fournit toutes les variables n√©cessaires pour les templates. "
                f"Difficult√©s affect√©es: {', '.join([m['difficulty'] for m in all_mismatches])}."
            )
            
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "ADMIN_TEMPLATE_MISMATCH",
                    "error": "admin_template_mismatch",
                    "message": f"Les templates contiennent des placeholders qui ne peuvent pas √™tre r√©solus par le g√©n√©rateur '{generator_key}'.",
                    "hint": hint,
                    "context": {
                        "generator_key": generator_key,
                        "mismatches": all_mismatches,
                        "missing_summary": sorted(missing_summary),
                        "placeholders_expected": sorted(placeholders_expected)
                    }
                }
            )
    
    async def _reload_handler(self, chapter_code: str) -> None:
        """Recharge le handler en m√©moire apr√®s modification"""
        try:
            import importlib
            
            if chapter_code == "6E_GM07":
                import data.gm07_exercises as module
                importlib.reload(module)
            elif chapter_code == "6E_GM08":
                import data.gm08_exercises as module
                importlib.reload(module)
            
            logger.info(f"Handler {chapter_code} recharg√©")
        except Exception as e:
            logger.error(f"Erreur rechargement handler {chapter_code}: {e}")


# =============================================================================
# SINGLETON
# =============================================================================

_exercise_persistence_service: Optional[ExercisePersistenceService] = None


def get_exercise_persistence_service(db: AsyncIOMotorDatabase) -> ExercisePersistenceService:
    """Factory pour obtenir le service de persistance des exercices"""
    global _exercise_persistence_service
    
    if _exercise_persistence_service is None:
        _exercise_persistence_service = ExercisePersistenceService(db)
    
    return _exercise_persistence_service

# ============================================================================
# 3. backend/services/curriculum_persistence_service.py
# ============================================================================

"""
Service de persistance du curriculum en MongoDB.

G√®re les op√©rations CRUD sur les chapitres du curriculum.
Maintient la synchronisation entre MongoDB et le fichier JSON local.
"""

import json
import os
import logging
from typing import Dict, List, Optional, Any, Literal
from datetime import datetime, timezone
from motor.motor_asyncio import AsyncIOMotorDatabase
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)

# Chemin vers le fichier JSON du curriculum
CURRICULUM_DIR = os.path.join(os.path.dirname(os.path.dirname(__file__)), "curriculum")
CURRICULUM_6E_PATH = os.path.join(CURRICULUM_DIR, "curriculum_6e.json")

# Collection MongoDB pour le curriculum
CURRICULUM_COLLECTION = "curriculum_chapters"


import re
from pydantic import field_validator
from typing import Literal as PyLiteral


def normalize_code_officiel(code: str) -> str:
    """
    Normalise le code officiel au format canonique.
    Accepte 6E_N99 ou 6e_N99 et retourne 6e_N99.
    Le niveau (6e, 5e, 4e, 3e) est en minuscules, le reste en majuscules.
    """
    code = code.strip()
    if not code:
        return code
    
    # Pattern: niveau_reste (ex: 6e_N01, 5e_G02)
    match = re.match(r'^(\d+[eE])_(.+)$', code)
    if match:
        niveau = match.group(1).lower()  # 6e, 5e, etc. en minuscules
        reste = match.group(2).upper()    # N01, G02, etc. en majuscules
        return f"{niveau}_{reste}"
    
    return code  # Retourne tel quel si le format n'est pas reconnu


# P4.B - Mod√®les pour enabled_generators
class EnabledGeneratorConfig(BaseModel):
    """Configuration d'un g√©n√©rateur activ√© dans un chapitre"""
    generator_key: str = Field(..., description="Cl√© du g√©n√©rateur (ex: THALES_V2)")
    difficulty_presets: List[str] = Field(
        default_factory=lambda: ["facile", "moyen", "difficile"],
        description="Liste des difficult√©s activ√©es pour ce g√©n√©rateur"
    )
    min_offer: str = Field(
        default="free",
        description="Offre minimum requise: 'free' ou 'pro'"
    )
    is_enabled: bool = Field(
        default=True,
        description="Si le g√©n√©rateur est activ√© dans ce chapitre"
    )


class ChapterCreateRequest(BaseModel):
    """Mod√®le pour la cr√©ation d'un chapitre"""
    code_officiel: str = Field(..., description="Code officiel unique (ex: 6e_N01)")
    libelle: str = Field(..., description="Intitul√© du chapitre")
    domaine: str = Field(default="Nombres et calculs", description="Domaine math√©matique")
    chapitre_backend: str = Field(default="", description="Nom du chapitre backend correspondant")
    exercise_types: List[str] = Field(default_factory=list, description="Types d'exercices associ√©s")
    schema_requis: bool = Field(default=False, description="Si un sch√©ma est requis")
    difficulte_min: int = Field(default=1, ge=1, le=3, description="Difficult√© minimum")
    difficulte_max: int = Field(default=3, ge=1, le=3, description="Difficult√© maximum")
    statut: str = Field(default="beta", description="Statut: prod, beta, hidden")
    tags: List[str] = Field(default_factory=list, description="Tags pour filtrage")
    contexts: List[str] = Field(default_factory=list, description="Contextes disponibles")
    pipeline: Optional[Literal["SPEC", "TEMPLATE", "MIXED"]] = Field(
        default="SPEC",
        description="Pipeline de g√©n√©ration: SPEC (statique), TEMPLATE (dynamique), MIXED (les deux)"
    )
    enabled_generators: List[EnabledGeneratorConfig] = Field(
        default_factory=list,
        description="Liste des g√©n√©rateurs activ√©s dans ce chapitre (P4.B)"
    )
    
    @field_validator('code_officiel', mode='before')
    @classmethod
    def normalize_code(cls, v: str) -> str:
        """Normalise le code_officiel au format canonique"""
        return normalize_code_officiel(v)


class ChapterUpdateRequest(BaseModel):
    """Mod√®le pour la mise √† jour d'un chapitre"""
    libelle: Optional[str] = None
    domaine: Optional[str] = None
    chapitre_backend: Optional[str] = None
    exercise_types: Optional[List[str]] = None
    schema_requis: Optional[bool] = None
    difficulte_min: Optional[int] = Field(default=None, ge=1, le=3)
    difficulte_max: Optional[int] = Field(default=None, ge=1, le=3)
    statut: Optional[str] = None
    tags: Optional[List[str]] = None
    contexts: Optional[List[str]] = None
    pipeline: Optional[Literal["SPEC", "TEMPLATE", "MIXED"]] = Field(
        default=None,
        description="Pipeline de g√©n√©ration: SPEC (statique), TEMPLATE (dynamique), MIXED (les deux)"
    )
    enabled_generators: Optional[List[EnabledGeneratorConfig]] = Field(
        default=None,
        description="Liste des g√©n√©rateurs activ√©s dans ce chapitre (P4.B)"
    )


class CurriculumPersistenceService:
    """
    Service de persistance pour le curriculum.
    G√®re la synchronisation MongoDB <-> fichier JSON.
    """
    
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.collection = db[CURRICULUM_COLLECTION]
        self._initialized = False
    
    async def initialize(self) -> None:
        """
        Initialise la collection MongoDB avec les donn√©es du fichier JSON.
        Ne fait rien si d√©j√† initialis√©.
        """
        if self._initialized:
            return
        
        # V√©rifier si la collection existe et a des donn√©es
        count = await self.collection.count_documents({"niveau": "6e"})
        
        if count == 0:
            # Charger depuis le fichier JSON
            logger.info("Initialisation de la collection curriculum depuis le fichier JSON")
            await self._load_from_json()
        
        # Cr√©er les index
        await self.collection.create_index("code_officiel", unique=True)
        await self.collection.create_index("niveau")
        await self.collection.create_index("domaine")
        await self.collection.create_index("statut")
        
        self._initialized = True
        logger.info(f"Curriculum persistence service initialis√© avec {count} chapitres")
    
    async def _load_from_json(self) -> None:
        """Charge les chapitres depuis le fichier JSON vers MongoDB"""
        if not os.path.exists(CURRICULUM_6E_PATH):
            logger.warning(f"Fichier curriculum non trouv√©: {CURRICULUM_6E_PATH}")
            return
        
        with open(CURRICULUM_6E_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        
        chapters = data.get("chapitres", [])
        
        if chapters:
            # Ajouter des m√©tadonn√©es
            for chapter in chapters:
                chapter["created_at"] = datetime.now(timezone.utc)
                chapter["updated_at"] = datetime.now(timezone.utc)
            
            await self.collection.insert_many(chapters)
            logger.info(f"Charg√© {len(chapters)} chapitres depuis le fichier JSON")
    
    async def _sync_to_json(self) -> None:
        """
        Synchronise les donn√©es MongoDB vers le fichier JSON.
        Maintient la compatibilit√© avec le syst√®me existant.
        """
        chapters = await self.collection.find(
            {"niveau": "6e"},
            {"_id": 0, "created_at": 0, "updated_at": 0}
        ).to_list(1000)
        
        # Trier par code_officiel
        chapters.sort(key=lambda x: x.get("code_officiel", ""))
        
        data = {
            "version": 1,
            "niveau": "6e",
            "description": "R√©f√©rentiel p√©dagogique officiel 6e bas√© sur le programme de math√©matiques",
            "chapitres": chapters
        }
        
        with open(CURRICULUM_6E_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"Fichier JSON synchronis√© avec {len(chapters)} chapitres")
    
    async def get_all_chapters(self, niveau: str = "6e") -> List[Dict[str, Any]]:
        """R√©cup√®re tous les chapitres d'un niveau"""
        await self.initialize()
        
        chapters = await self.collection.find(
            {"niveau": niveau},
            {"_id": 0}
        ).sort("code_officiel", 1).to_list(1000)
        
        return chapters
    
    async def get_chapter_by_code(self, code_officiel: str) -> Optional[Dict[str, Any]]:
        """R√©cup√®re un chapitre par son code officiel"""
        await self.initialize()
        
        # P0 - DIAGNOSTIC : Log de la requ√™te exacte
        logger.info(
            f"[DIAG_6E_G07] get_chapter_by_code() appel√© avec code_officiel='{code_officiel}' "
            f"(type: {type(code_officiel)})"
        )
        
        chapter = await self.collection.find_one(
            {"code_officiel": code_officiel},
            {"_id": 0}
        )
        
        if chapter:
            logger.info(
                f"[DIAG_6E_G07] ‚úÖ Chapitre trouv√©: code_officiel='{chapter.get('code_officiel')}', "
                f"pipeline='{chapter.get('pipeline')}'"
            )
        else:
            logger.warning(
                f"[DIAG_6E_G07] ‚ùå Chapitre NON TROUV√â avec code_officiel='{code_officiel}'. "
                f"V√©rifier la casse dans MongoDB."
            )
        
        return chapter
    
    async def create_chapter(self, request: ChapterCreateRequest) -> Dict[str, Any]:
        """
        Cr√©e un nouveau chapitre.
        
        Args:
            request: Donn√©es du nouveau chapitre
            
        Returns:
            Le chapitre cr√©√©
            
        Raises:
            ValueError: Si le code_officiel existe d√©j√† ou validation √©choue
        """
        await self.initialize()
        
        # V√©rifier l'unicit√© du code
        existing = await self.collection.find_one({"code_officiel": request.code_officiel})
        if existing:
            raise ValueError(f"Le code officiel '{request.code_officiel}' existe d√©j√†")
        
        # P0: Validations BLOQUANTES
        pipeline_mode = request.pipeline or "SPEC"
        
        # Validation 1: TEMPLATE sans exercice dynamique ‚Üí ERREUR
        if pipeline_mode == "TEMPLATE":
            from backend.services.curriculum_sync_service import get_curriculum_sync_service
            sync_service = get_curriculum_sync_service(self.db)
            chapter_code_upper = request.code_officiel.upper().replace("-", "_")
            
            has_exercises = await sync_service.has_exercises_in_db(chapter_code_upper)
            if not has_exercises:
                raise ValueError(
                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                    f"mais aucun exercice dynamique n'existe en DB pour ce chapitre. "
                    f"Cr√©ez au moins un exercice dynamique ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                )
            
            # V√©rifier qu'il y a au moins un exercice dynamique
            from backend.services.exercise_persistence_service import get_exercise_persistence_service
            exercise_service = get_exercise_persistence_service(self.db)
            exercises = await exercise_service.get_exercises(chapter_code=chapter_code_upper)
            dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
            
            if len(dynamic_exercises) == 0:
                raise ValueError(
                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                    f"mais aucun exercice dynamique (is_dynamic=true) n'existe en DB. "
                    f"Cr√©ez au moins un exercice dynamique ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                )
        
        # Validation 2: SPEC avec exercise_types invalides ‚Üí ERREUR
        # Permet √† la fois les MathExerciseType (statiques) et les generator_keys (dynamiques)
        if pipeline_mode == "SPEC" and request.exercise_types:
            from backend.models.math_models import MathExerciseType
            from backend.generators.factory import GeneratorFactory
            
            invalid_types = []
            for et in request.exercise_types:
                # V√©rifier si c'est un MathExerciseType (statique)
                is_math_type = hasattr(MathExerciseType, et)
                # V√©rifier si c'est un generator_key (dynamique)
                is_generator = GeneratorFactory.get(et) is not None
                
                if not is_math_type and not is_generator:
                    invalid_types.append(et)
            
            if len(invalid_types) == len(request.exercise_types) and len(invalid_types) > 0:
                # Tous les types sont invalides
                raise ValueError(
                    f"Le chapitre '{request.code_officiel}' est configur√© avec pipeline='SPEC' "
                    f"mais tous les exercise_types configur√©s ne correspondent √† aucun "
                    f"MathExerciseType connu ni √† aucun g√©n√©rateur dynamique: {invalid_types}. "
                    f"Ajoutez ces types dans MathExerciseType ou enregistrez ces g√©n√©rateurs dans GeneratorFactory, "
                    f"corrigez le r√©f√©rentiel, ou changez le pipeline √† 'TEMPLATE' ou 'MIXED'."
                )
        
        # Construire le document
        chapter = {
            "niveau": "6e",  # Hardcod√© pour l'instant (V2 = 6e uniquement)
            **request.model_dump(),
            "created_at": datetime.now(timezone.utc),
            "updated_at": datetime.now(timezone.utc)
        }
        
        await self.collection.insert_one(chapter)
        
        # Synchroniser avec le fichier JSON
        await self._sync_to_json()
        
        # Recharger le curriculum en m√©moire
        await self._reload_curriculum_index()
        
        logger.info(f"Chapitre cr√©√©: {request.code_officiel}")
        
        # Retourner sans _id
        del chapter["_id"]
        return chapter
    
    async def update_chapter(self, code_officiel: str, request: ChapterUpdateRequest) -> Dict[str, Any]:
        """
        Met √† jour un chapitre existant.
        
        Args:
            code_officiel: Code du chapitre √† modifier
            request: Donn√©es √† mettre √† jour (seuls les champs non-None sont mis √† jour)
            
        Returns:
            Le chapitre mis √† jour
            
        Raises:
            ValueError: Si le chapitre n'existe pas
        """
        await self.initialize()
        
        # V√©rifier l'existence
        existing = await self.collection.find_one({"code_officiel": code_officiel})
        if not existing:
            raise ValueError(f"Le code officiel '{code_officiel}' n'existe pas")
        
        # Construire les champs √† mettre √† jour
        update_data = request.model_dump(exclude_none=True)
        
        if not update_data:
            # Rien √† mettre √† jour
            del existing["_id"]
            return existing
        
        # P0: Validations BLOQUANTES
        # D√©terminer le pipeline (nouveau ou existant)
        pipeline_mode = update_data.get("pipeline") or existing.get("pipeline") or "SPEC"
        
        # D√©terminer les exercise_types (nouveaux ou existants)
        exercise_types = update_data.get("exercise_types") or existing.get("exercise_types", [])
        
        # Validation 1: TEMPLATE sans exercice dynamique ‚Üí ERREUR
        if pipeline_mode == "TEMPLATE":
            from backend.services.curriculum_sync_service import get_curriculum_sync_service
            sync_service = get_curriculum_sync_service(self.db)
            chapter_code_upper = code_officiel.upper().replace("-", "_")
            
            has_exercises = await sync_service.has_exercises_in_db(chapter_code_upper)
            if not has_exercises:
                raise ValueError(
                    f"Le chapitre '{code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                    f"mais aucun exercice dynamique n'existe en DB pour ce chapitre. "
                    f"Cr√©ez au moins un exercice dynamique ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                )
            
            # V√©rifier qu'il y a au moins un exercice dynamique
            from backend.services.exercise_persistence_service import get_exercise_persistence_service
            exercise_service = get_exercise_persistence_service(self.db)
            exercises = await exercise_service.get_exercises(chapter_code=chapter_code_upper)
            dynamic_exercises = [ex for ex in exercises if ex.get("is_dynamic") is True]
            
            if len(dynamic_exercises) == 0:
                raise ValueError(
                    f"Le chapitre '{code_officiel}' est configur√© avec pipeline='TEMPLATE' "
                    f"mais aucun exercice dynamique (is_dynamic=true) n'existe en DB. "
                    f"Cr√©ez au moins un exercice dynamique ou changez le pipeline √† 'SPEC' ou 'MIXED'."
                )
        
        # Validation 2: SPEC avec exercise_types invalides ‚Üí ERREUR
        # Permet √† la fois les MathExerciseType (statiques) et les generator_keys (dynamiques)
        if pipeline_mode == "SPEC" and exercise_types:
            from backend.models.math_models import MathExerciseType
            from backend.generators.factory import GeneratorFactory
            
            invalid_types = []
            for et in exercise_types:
                # V√©rifier si c'est un MathExerciseType (statique)
                is_math_type = hasattr(MathExerciseType, et)
                # V√©rifier si c'est un generator_key (dynamique)
                is_generator = GeneratorFactory.get(et) is not None
                
                if not is_math_type and not is_generator:
                    invalid_types.append(et)
            
            if len(invalid_types) == len(exercise_types) and len(invalid_types) > 0:
                # Tous les types sont invalides
                raise ValueError(
                    f"Le chapitre '{code_officiel}' est configur√© avec pipeline='SPEC' "
                    f"mais tous les exercise_types configur√©s ne correspondent √† aucun "
                    f"MathExerciseType connu ni √† aucun g√©n√©rateur dynamique: {invalid_types}. "
                    f"Ajoutez ces types dans MathExerciseType ou enregistrez ces g√©n√©rateurs dans GeneratorFactory, "
                    f"corrigez le r√©f√©rentiel, ou changez le pipeline √† 'TEMPLATE' ou 'MIXED'."
                )
        
        update_data["updated_at"] = datetime.now(timezone.utc)
        
        await self.collection.update_one(
            {"code_officiel": code_officiel},
            {"$set": update_data}
        )
        
        # Synchroniser avec le fichier JSON
        await self._sync_to_json()
        
        # Recharger le curriculum en m√©moire
        await self._reload_curriculum_index()
        
        logger.info(f"Chapitre mis √† jour: {code_officiel}")
        
        # R√©cup√©rer le chapitre mis √† jour
        updated = await self.collection.find_one(
            {"code_officiel": code_officiel},
            {"_id": 0}
        )
        
        return updated
    
    async def delete_chapter(self, code_officiel: str) -> bool:
        """
        Supprime un chapitre.
        
        Args:
            code_officiel: Code du chapitre √† supprimer
            
        Returns:
            True si supprim√©, False sinon
            
        Raises:
            ValueError: Si le chapitre n'existe pas
        """
        await self.initialize()
        
        # V√©rifier l'existence
        existing = await self.collection.find_one({"code_officiel": code_officiel})
        if not existing:
            raise ValueError(f"Le code officiel '{code_officiel}' n'existe pas")
        
        result = await self.collection.delete_one({"code_officiel": code_officiel})
        
        if result.deleted_count > 0:
            # Synchroniser avec le fichier JSON
            await self._sync_to_json()
            
            # Recharger le curriculum en m√©moire
            await self._reload_curriculum_index()
            
            logger.info(f"Chapitre supprim√©: {code_officiel}")
            return True
        
        return False
    
    async def _reload_curriculum_index(self) -> None:
        """
        Recharge l'index du curriculum en m√©moire.
        N√©cessaire apr√®s chaque modification pour que les changements soient pris en compte.
        """
        try:
            from curriculum.loader import load_curriculum_6e, _curriculum_index
            import curriculum.loader as loader_module
            
            # R√©initialiser le singleton
            loader_module._curriculum_index = None
            
            # Recharger
            load_curriculum_6e()
            
            logger.info("Index curriculum recharg√© en m√©moire")
        except Exception as e:
            logger.error(f"Erreur lors du rechargement de l'index: {e}")
    
    async def get_available_generators(self) -> List[str]:
        """
        R√©cup√®re la liste de tous les g√©n√©rateurs disponibles.
        
        **Source de v√©rit√© enrichie** :
        - G√©n√©rateurs statiques : MathExerciseType (source principale)
        - G√©n√©rateurs dynamiques : exercise_types extraits depuis GeneratorFactory
          via le mapping GENERATOR_TO_EXERCISE_TYPE (utilise les exercise_types du curriculum,
          pas ceux des m√©tadonn√©es)
        
        Utile pour le formulaire d'√©dition dans l'admin.
        """
        generators = set()
        
        # 1. G√©n√©rateurs statiques (MathExerciseType)
        try:
            from models.math_models import MathExerciseType
            for e in MathExerciseType:
                generators.add(e.name)
        except Exception as e:
            logger.warning(f"Erreur lors de la r√©cup√©ration des g√©n√©rateurs statiques: {e}")
        
        # 2. G√©n√©rateurs dynamiques (GeneratorFactory) - source unique via meta.exercise_type
        try:
            from backend.generators.factory import GeneratorFactory
            
            # R√©cup√©rer tous les g√©n√©rateurs Factory
            factory_generators = GeneratorFactory.list_all()
            
            for gen_info in factory_generators:
                generator_key = gen_info.get("key")
                if generator_key:
                    exercise_type = gen_info.get("exercise_type")
                    if exercise_type:
                        generators.add(exercise_type)
                        logger.debug(
                            f"[AVAILABLE_GENERATORS] G√©n√©rateur dynamique {generator_key} ‚Üí "
                            f"exercise_type: {exercise_type}"
                        )
        except Exception as e:
            logger.warning(f"Erreur lors de la r√©cup√©ration des g√©n√©rateurs dynamiques: {e}")
        
        # Retourner la liste tri√©e
        return sorted(list(generators))
    
    async def get_available_domaines(self) -> List[str]:
        """
        R√©cup√®re la liste des domaines uniques depuis la base.
        """
        await self.initialize()
        
        domaines = await self.collection.distinct("domaine")
        return sorted(domaines)
    
    async def get_stats(self) -> Dict[str, Any]:
        """
        Retourne des statistiques sur le curriculum.
        """
        await self.initialize()
        
        total = await self.collection.count_documents({"niveau": "6e"})
        by_status = {}
        by_domaine = {}
        
        # Agr√©gation par statut
        status_agg = await self.collection.aggregate([
            {"$match": {"niveau": "6e"}},
            {"$group": {"_id": "$statut", "count": {"$sum": 1}}}
        ]).to_list(100)
        
        for item in status_agg:
            by_status[item["_id"]] = item["count"]
        
        # Agr√©gation par domaine
        domaine_agg = await self.collection.aggregate([
            {"$match": {"niveau": "6e"}},
            {"$group": {"_id": "$domaine", "count": {"$sum": 1}}}
        ]).to_list(100)
        
        for item in domaine_agg:
            by_domaine[item["_id"]] = item["count"]
        
        return {
            "total": total,
            "by_status": by_status,
            "by_domaine": by_domaine
        }


# Singleton pour le service (sera initialis√© avec la DB)
_curriculum_persistence_service: Optional[CurriculumPersistenceService] = None


def get_curriculum_persistence_service(db: AsyncIOMotorDatabase) -> CurriculumPersistenceService:
    """
    Factory pour obtenir le service de persistance.
    Cr√©e une instance unique par base de donn√©es.
    """
    global _curriculum_persistence_service
    
    if _curriculum_persistence_service is None:
        _curriculum_persistence_service = CurriculumPersistenceService(db)
    
    return _curriculum_persistence_service

# ============================================================================
# 4. backend/generators/factory.py
# ============================================================================

"""
Dynamic Factory - Registry Central des G√©n√©rateurs
===================================================

Version: 2.0.0 (Dynamic Factory v1)

Ce module fournit:
- Un registry central unique pour tous les g√©n√©rateurs
- L'API publique pour lister, r√©cup√©rer les sch√©mas et g√©n√©rer
- La fusion des param√®tres (defaults + exercise + overrides)

Endpoints expos√©s:
- GET /api/v1/exercises/generators
- GET /api/v1/exercises/generators/{key}/schema
"""

from typing import Dict, Any, List, Optional, Type
import time
import logging
from backend.generators.base_generator import BaseGenerator, GeneratorMeta, ParamSchema, Preset
from backend.observability import (
    get_logger as get_obs_logger,
    get_request_context,
)

logger = logging.getLogger(__name__)
obs_logger = get_obs_logger('GENERATOR_FACTORY')


# =============================================================================
# REGISTRY CENTRAL
# =============================================================================

class GeneratorFactory:
    """Factory centrale pour tous les g√©n√©rateurs."""
    
    _generators: Dict[str, Type[BaseGenerator]] = {}
    
    # P4.1 - G√©n√©rateurs d√©sactiv√©s (non utilisables)
    # Cette liste est mise √† jour manuellement apr√®s classification
    # Pour mettre √† jour : ex√©cuter test_dynamic_generators.py puis classify_generators.py
    DISABLED_GENERATORS: List[str] = [
        # Exemple (√† remplacer par les r√©sultats r√©els de classification) :
        # "SIMPLIFICATION_FRACTIONS_V1",
    ]
    
    # Aliases pour compatibilit√© arri√®re (cl√©s legacy -> nouveaux g√©n√©rateurs)
    _ALIASES: Dict[str, str] = {
        # Ancienne cl√© g√©n√©rique pour la sym√©trie axiale ‚Üí nouveau g√©n√©rateur Factory
        "SYMETRIE_AXIALE": "SYMETRIE_AXIALE_V2",
        # Alias Thal√®s (saisie avec espace ou sans suffixe)
        "THALES": "THALES_V2",
        "THALES V1": "THALES_V2",
        "THALES_V1": "THALES_V2",
    }

    @classmethod
    def register(cls, generator_class: Type[BaseGenerator]) -> Type[BaseGenerator]:
        """
        Enregistre un g√©n√©rateur dans le registry.
        
        Utilisable comme d√©corateur:
        @GeneratorFactory.register
        class MyGenerator(BaseGenerator):
            ...
        """
        meta = generator_class.get_meta()
        cls._generators[meta.key] = generator_class
        return generator_class
    
    @classmethod
    def get(cls, key: str) -> Optional[Type[BaseGenerator]]:
        """R√©cup√®re une classe de g√©n√©rateur par sa cl√©."""
        normalized = key.upper()
        # Appliquer les alias pour compatibilit√© arri√®re
        normalized = cls._ALIASES.get(normalized, normalized)
        
        # P4.1 - V√©rifier si le g√©n√©rateur est d√©sactiv√©
        if normalized in cls.DISABLED_GENERATORS:
            logger.warning(
                f"[GENERATOR_DISABLED] Tentative d'utilisation du g√©n√©rateur d√©sactiv√©: {normalized}"
            )
            return None
        
        return cls._generators.get(normalized)
    
    @classmethod
    def list_all(cls, include_disabled: bool = False) -> List[Dict[str, Any]]:
        """
        Liste tous les g√©n√©rateurs avec leurs m√©tadonn√©es.
        
        P1.2: Inclut is_dynamic, supported_grades, supported_chapters pour le filtrage UI.
        P4.1: Exclut les g√©n√©rateurs d√©sactiv√©s par d√©faut.
        
        Args:
            include_disabled: Si True, inclut aussi les g√©n√©rateurs d√©sactiv√©s
        """
        result = []
        for key, gen_class in cls._generators.items():
            # P4.1 - Filtrer les g√©n√©rateurs d√©sactiv√©s
            if not include_disabled and key in cls.DISABLED_GENERATORS:
                continue
            
            meta = gen_class.get_meta()
            result.append({
                "key": meta.key,
                "label": meta.label,
                "description": meta.description,
                "version": meta.version,
                "niveaux": meta.niveaux,
                "exercise_type": meta.exercise_type,
                "svg_mode": meta.svg_mode,
                "supports_double_svg": meta.supports_double_svg,
                "param_count": len(gen_class.get_schema()),
                "preset_count": len(gen_class.get_presets()),
                # P1.2 - M√©tadonn√©es pour filtrage
                "is_dynamic": getattr(meta, 'is_dynamic', True),  # Par d√©faut True pour compatibilit√©
                "supported_grades": getattr(meta, 'supported_grades', meta.niveaux),  # Fallback sur niveaux
                "supported_chapters": getattr(meta, 'supported_chapters', []),  # Optionnel
                # P4.1 - Statut de d√©sactivation
                "disabled": key in cls.DISABLED_GENERATORS
            })
        return result
    
    @classmethod
    def get_schema(cls, key: str) -> Optional[Dict[str, Any]]:
        """R√©cup√®re le sch√©ma complet d'un g√©n√©rateur."""
        normalized = key.upper()
        normalized = cls._ALIASES.get(normalized, normalized)
        
        # P4.1 - V√©rifier si le g√©n√©rateur est d√©sactiv√©
        if normalized in cls.DISABLED_GENERATORS:
            logger.warning(
                f"[GENERATOR_DISABLED] Tentative de r√©cup√©ration du sch√©ma d'un g√©n√©rateur d√©sactiv√©: {normalized}"
            )
            return None
        
        gen_class = cls.get(normalized)
        if not gen_class:
            return None
        
        meta = gen_class.get_meta()
        schema = gen_class.get_schema()
        defaults = gen_class.get_defaults()
        presets = gen_class.get_presets()
        
        return {
            "generator_key": meta.key,
            "meta": meta.to_dict(),
            "defaults": defaults,
            "schema": [p.to_dict() for p in schema],
            "presets": [p.to_dict() for p in presets]
        }
    
    @classmethod
    def get_exercise_type(cls, key: str) -> Optional[str]:
        """
        Source de v√©rit√© unique: r√©cup√®re l'exercise_type d√©clar√© dans le GeneratorMeta.
        Applique les alias avant de r√©soudre la classe.
        """
        normalized = key.upper()
        normalized = cls._ALIASES.get(normalized, normalized)
        gen_class = cls._generators.get(normalized)
        if not gen_class:
            return None
        meta = gen_class.get_meta()
        return meta.exercise_type if meta else None
    
    @classmethod
    def create_instance(cls, key: str, seed: Optional[int] = None) -> Optional[BaseGenerator]:
        """Cr√©e une instance d'un g√©n√©rateur."""
        gen_class = cls.get(key)
        if not gen_class:
            return None
        return gen_class(seed=seed)
    
    @classmethod
    def generate(
        cls,
        key: str,
        exercise_params: Optional[Dict[str, Any]] = None,
        overrides: Optional[Dict[str, Any]] = None,
        seed: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        G√©n√®re un exercice avec fusion des param√®tres.
        
        Ordre de fusion: defaults < exercise_params < overrides
        
        P4.1 - L√®ve une exception si le g√©n√©rateur est d√©sactiv√©.
        
        Args:
            key: Cl√© du g√©n√©rateur
            exercise_params: Params stock√©s dans l'exercice (admin)
            overrides: Params du prof (live)
            seed: Graine pour reproductibilit√©
        
        Returns:
            Exercice g√©n√©r√© complet
        """
        normalized = key.upper()
        normalized = cls._ALIASES.get(normalized, normalized)
        
        # P4.1 - V√©rifier si le g√©n√©rateur est d√©sactiv√©
        if normalized in cls.DISABLED_GENERATORS:
            logger.error(
                f"[GENERATOR_DISABLED] Tentative de g√©n√©ration avec g√©n√©rateur d√©sactiv√©: {normalized}"
            )
            raise ValueError(
                f"Le g√©n√©rateur '{normalized}' est d√©sactiv√© et ne peut pas √™tre utilis√©. "
                f"Consultez docs/CLASSIFICATION_GENERATEURS.md pour plus d'informations."
            )
        
        gen_start = time.time()
        obs_logger = get_obs_logger('GENERATOR')
        ctx = get_request_context()
        ctx.update({
            'generator_key': normalized,
            'seed': seed,
        })
        ctx.pop("exc_info", None)
        ctx.pop("stack_info", None)
        
        # Log d√©but g√©n√©ration
        obs_logger.info(
            "event=generate_in",
            event="generate_in",
            outcome="in_progress",
            **ctx
        )
        
        # Log params (DEBUG uniquement si LOG_VERBOSE=1)
        if exercise_params or overrides:
            obs_logger.debug(
                "event=params",
                event="params",
                outcome="in_progress",
                exercise_params_keys=list(exercise_params.keys()) if exercise_params else [],
                overrides_keys=list(overrides.keys()) if overrides else [],
                **ctx
            )
        
        try:
            gen_class = cls.get(normalized)
            if not gen_class:
                obs_logger.error(
                    "event=generator_unknown",
                    event="generator_unknown",
                    outcome="error",
                    reason="generator_key_unknown",
                    generator_key=key,
                    available_generators=list(cls._generators.keys()),
                    **ctx
                )
                raise ValueError(f"G√©n√©rateur inconnu: {key}. Disponibles: {list(cls._generators.keys())}")
            
            # Fusion des param√®tres
            merged = gen_class.merge_params(exercise_params or {}, overrides or {})
            
            # Validation
            valid, result = gen_class.validate_params(merged)
            if not valid:
                ctx.pop("exc_info", None)
                ctx.pop("stack_info", None)
                obs_logger.error(
                    "event=params_invalid",
                    event="params_invalid",
                    outcome="error",
                    reason="validation_failed",
                    validation_errors=result if isinstance(result, list) else [str(result)],
                    **ctx
                )
                raise ValueError(f"Param√®tres invalides: {result}")
            
            # G√©n√©ration
            generator = gen_class(seed=seed)
            output = generator.generate(result)
            
            # Ajouter les m√©tadonn√©es de g√©n√©ration
            meta = gen_class.get_meta()
            output["generation_meta"] = {
                "generator_key": meta.key,
                "generator_version": meta.version,
                "exercise_type": meta.exercise_type,
                "svg_mode": meta.svg_mode,
                "params_used": result,
                "seed": seed
            }
            
            # Log succ√®s
            gen_duration_ms = int((time.time() - gen_start) * 1000)
            ctx.update({
                'variant_id': result.get('variant_id'),
                'pedagogy_mode': result.get('pedagogy_mode'),
            })
            logger.info(
                f"[GENERATOR_OK] ‚úÖ G√©n√©ration r√©ussie: generator={key}, "
                f"duration_ms={gen_duration_ms}, variables={len(output.get('variables', {}))}, "
                f"svg_enonce={output.get('figure_svg_enonce') is not None}, "
                f"svg_solution={output.get('figure_svg_solution') is not None}"
            )
            obs_logger.info(
                "event=generate_complete",
                event="generate_complete",
                outcome="success",
                duration_ms=gen_duration_ms,
                variables_count=len(output.get('variables', {})),
                has_svg_enonce=output.get('figure_svg_enonce') is not None,
                has_svg_solution=output.get('figure_svg_solution') is not None,
                **ctx
            )
            
            return output
            
        except Exception as e:
            gen_duration_ms = int((time.time() - gen_start) * 1000)
            logger.error(
                f"[GENERATOR_FAIL] ‚ùå G√©n√©ration √©chou√©e: generator={key}, "
                f"duration_ms={gen_duration_ms}, exception={type(e).__name__}, "
                f"message={str(e)[:200]}"
            )
            obs_logger.error(
                "event=generate_exception",
                event="generate_exception",
                outcome="error",
                duration_ms=gen_duration_ms,
                reason="generation_failed",
                exception_type=type(e).__name__,
                exception_message=str(e)[:200],
                **ctx,
                exc_info=True
            )
            raise


# =============================================================================
# API FONCTIONS PUBLIQUES
# =============================================================================

def get_generators_list() -> List[Dict[str, Any]]:
    """Liste tous les g√©n√©rateurs disponibles."""
    return GeneratorFactory.list_all()


def get_generator_schema(key: str) -> Optional[Dict[str, Any]]:
    """R√©cup√®re le sch√©ma complet d'un g√©n√©rateur."""
    return GeneratorFactory.get_schema(key)


def generate_exercise(
    generator_key: str,
    exercise_params: Optional[Dict[str, Any]] = None,
    overrides: Optional[Dict[str, Any]] = None,
    seed: Optional[int] = None
) -> Dict[str, Any]:
    """
    API principale pour g√©n√©rer un exercice.
    
    Params effectifs = defaults + exercise_params + overrides
    """
    # generate() applique d√©j√† l'aliasing via GeneratorFactory.get()
    return GeneratorFactory.generate(
        key=generator_key,
        exercise_params=exercise_params,
        overrides=overrides,
        seed=seed,
    )


def validate_exercise_params(generator_key: str, params: Dict[str, Any]) -> tuple:
    """Valide des param√®tres pour un g√©n√©rateur."""
    gen_class = GeneratorFactory.get(generator_key)
    if not gen_class:
        return False, [f"G√©n√©rateur inconnu: {generator_key}"]
    return gen_class.validate_params(params)


# =============================================================================
# AUTO-IMPORT DES G√âN√âRATEURS
# =============================================================================

def _register_all_generators():
    """Importe et enregistre tous les g√©n√©rateurs."""
    # Import des g√©n√©rateurs existants et nouveaux
    try:
        from backend.generators.thales_v2 import ThalesV2Generator  # noqa:F401
    except ImportError:
        pass
    
    try:
        from backend.generators.symetrie_axiale_v2 import SymetrieAxialeV2Generator  # noqa:F401
    except ImportError:
        pass

    try:
        from backend.generators.thales_generator import ThalesGenerator  # noqa:F401
    except ImportError:
        pass
    
    try:
        from backend.generators.simplification_fractions_v1 import SimplificationFractionsV1Generator  # noqa:F401
    except ImportError:
        pass
    
    try:
        from backend.generators.simplification_fractions_v2 import SimplificationFractionsV2Generator  # noqa:F401
    except ImportError:
        pass
    
    try:
        from backend.generators.calcul_nombres_v1 import CalculNombresV1Generator  # noqa:F401
    except ImportError:
        pass
    
    try:
        from backend.generators.raisonnement_multiplicatif_v1 import RaisonnementMultiplicatifV1Generator  # noqa:F401
    except ImportError:
        pass


# Auto-register au chargement du module
_register_all_generators()

# ============================================================================
# 5. backend/services/tests_dyn_handler.py (format_dynamic_exercise)
# ============================================================================

"""
Handler pour les exercices dynamiques (TESTS_DYN)
=================================================

Ce handler g√®re la g√©n√©ration d'exercices dynamiques utilisant des templates
et des g√©n√©rateurs de variables (comme THALES_V1).

Workflow:
1. S√©lectionner un exercice template depuis tests_dyn_exercises.py
2. Appeler le g√©n√©rateur (generator_key) pour obtenir les variables
3. Enrichir les variables (mappings alias) pour compatibilit√© template/g√©n√©rateur
4. Rendre les templates avec les variables
5. G√©n√©rer les SVG depuis les variables
6. Retourner l'exercice complet, ou une erreur JSON propre si placeholders non r√©solus
"""

import time
import random
import re
from types import SimpleNamespace
from typing import Dict, Any, Optional, List, Set

from fastapi import HTTPException

from backend.data.tests_dyn_exercises import (
    get_tests_dyn_exercises,
    get_tests_dyn_batch,
    get_tests_dyn_stats,
    get_random_tests_dyn_exercise
)
from backend.generators.thales_generator import generate_dynamic_exercise, GENERATORS_REGISTRY
from backend.generators.factory import GeneratorFactory
from backend.services.template_renderer import render_template, get_template_variables
from backend.services.dynamic_exercise_engine import choose_template_variant
from backend.services.variants_config import is_chapter_template_based
from backend.logger import get_logger
from backend.observability import (
    get_logger as get_obs_logger,
    set_request_context,
    get_request_context,
)

logger = get_logger()
obs_logger = get_obs_logger('TESTS_DYN')


def is_tests_dyn_request(code_officiel: Optional[str]) -> bool:
    """V√©rifie si la requ√™te concerne le chapitre TESTS_DYN."""
    if not code_officiel:
        return False
    return code_officiel.upper() in ["6E_TESTS_DYN", "TESTS_DYN"]


def _extract_placeholders(template_str: str) -> Set[str]:
    """
    Extrait les placeholders {{variable}} d'un template.
    Utilis√© uniquement pour debug / garde anti-placeholders.
    """
    if not template_str:
        return set()
    pattern = r"\{\{\s*([a-zA-Z0-9_]+)\s*\}\}"
    return set(re.findall(pattern, template_str))


def _normalize_figure_type(raw: Optional[str]) -> Optional[str]:
    """
    Normalise le type de figure pour THALES_V1.
    - lower + trim
    - enl√®ve les accents simples
    - mappe quelques synonymes √©vidents (square -> carre, etc.)
    """
    if not raw:
        return None

    v = str(raw).strip().lower()
    # Normalisation minimale pour les cas connus
    mapping = {
        "carr√©": "carre",
        "square": "carre",
    }
    return mapping.get(v, v)


def format_dynamic_exercise(
    exercise_template: Dict[str, Any],
    timestamp: int,
    seed: Optional[int] = None,
    overrides: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """
    Formate un exercice dynamique complet.
    
    Args:
        exercise_template: Template d'exercice depuis la DB
        timestamp: Timestamp pour l'ID unique
        seed: Seed pour le g√©n√©rateur (reproductibilit√©)
        overrides: Param√®tres √† √©craser (ex: difficulty de la requ√™te HTTP)
    
    Returns:
        Exercice format√© avec HTML rendu et SVG g√©n√©r√©s.

    Important:
    - Ajoute des alias de variables pour compatibilit√© template/g√©n√©rateur
      (rectangle / triangle / carr√©)
    - Garde d√©terminisme via le seed (aucun random global ajout√© ici)
    - Si des placeholders {{...}} restent apr√®s rendu, l√®ve une HTTPException
      422 PLACEHOLDER_UNRESOLVED pour √©viter d'envoyer un √©nonc√© cass√©.
    """
    handler_start = time.time()
    chapter_code = (exercise_template.get("chapter_code") or "6E_TESTS_DYN").upper()
    exercise_id = f"ex_{chapter_code.lower()}_{exercise_template['id']}_{timestamp}"
    is_premium = exercise_template["offer"] == "pro"
    
    # R√©cup√©rer le g√©n√©rateur
    generator_key = exercise_template.get("generator_key", "THALES_V1")
    difficulty = exercise_template.get("difficulty", "moyen")
    template_id = exercise_template.get("id")
    
    # Mettre √† jour le contexte partag√©
    ctx = get_request_context()
    ctx.update({
        'chapter_code': chapter_code,
        'generator_key': generator_key,
        'template_id': template_id,
        'exercise_id': exercise_id,
        'admin_exercise_id': template_id,
        'difficulty': difficulty,
        'seed': seed,
    })
    # Nettoyer les cl√©s r√©serv√©es du contexte pour √©viter des erreurs de logging
    ctx.pop("exc_info", None)
    ctx.pop("stack_info", None)
    set_request_context(**ctx)
    
    # Log d√©but handler
    obs_logger.info(
        "event=handler_in",
        event="handler_in",
        outcome="in_progress",
        **ctx
    )
    
    # R√©cup√©rer les param√®tres de l'exercice (configur√©s dans l'admin)
    exercise_params = exercise_template.get("variables") or {}
    
    # S'assurer que le difficulty de l'exercice est inclus dans les param√®tres
    # (si non pr√©sent dans variables, utiliser celui de l'exercice)
    if "difficulty" not in exercise_params:
        exercise_params["difficulty"] = difficulty
    
    # G√©n√©rer les variables et SVG (d√©pend uniquement du seed + difficulty)
    # Ordre de fusion: defaults < exercise_params < overrides
    gen_start = time.time()
    factory_gen = GeneratorFactory.get(generator_key)
    if factory_gen:
        try:
            gen_result = GeneratorFactory.generate(
                key=generator_key,
                exercise_params=exercise_params,
                overrides=overrides,
                seed=seed,
            )
            variables = gen_result.get("variables", {})
            results = gen_result.get("results", {})
        except ValueError as e:
            obs_logger.error(
                "event=generate_exception",
                event="generate_exception",
                outcome="error",
                reason="params_invalid",
                **ctx
            )
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "GENERATOR_PARAMS_INVALID",
                    "error": "generator_params_invalid",
                    "message": str(e),
                }
            )
    else:
        gen_result = generate_dynamic_exercise(
            generator_key=generator_key,
            seed=seed,
            difficulty=difficulty
        )
        variables = gen_result["variables"]
        results = gen_result["results"]
    
    gen_duration_ms = int((time.time() - gen_start) * 1000)
    obs_logger.debug(
        "event=generator_complete",
        event="generator_complete",
        outcome="success",
        duration_ms=gen_duration_ms,
        variables_count=len(variables),
        results_count=len(results),
        **ctx
    )
    
    # Fusionner variables et results pour le rendu
    all_vars: Dict[str, Any] = {**variables, **results}

    # Alias THALES_V1 : mapping explicite et d√©terministe (√©viter placeholders r√©siduels)
    if generator_key.startswith("THALES"):
        alias_actions = []

        def apply_alias(target: str, candidates: List[str]) -> None:
            if target in all_vars and all_vars[target] is not None:
                return
            for cand in candidates:
                if cand in all_vars and all_vars[cand] is not None:
                    all_vars[target] = all_vars[cand]
                    alias_actions.append((target, cand))
                    return

        apply_alias("cote_initial", ["cote_initial", "base_initiale", "longueur_initiale", "largeur_initiale"])
        apply_alias("cote_final", ["cote_final", "base_finale", "longueur_finale", "largeur_finale"])

        missing_alias = [k for k in ("cote_initial", "cote_final") if k not in all_vars or all_vars[k] is None]
        if missing_alias:
            obs_logger.error(
                "event=alias_missing",
                event="alias_missing",
                outcome="error",
                reason="placeholder_alias_missing",
                missing_placeholders=",".join(missing_alias),
                available_keys_count=len(all_vars),
                **ctx
            )
            logger.error(
                f"[PLACEHOLDER_ALIAS] Impossible de r√©soudre {missing_alias} pour {generator_key} "
                f"(candidats pr√©sents: {[k for k in all_vars.keys()]})"
            )
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "PLACEHOLDER_ALIAS_MISSING",
                    "error": "placeholder_alias_missing",
                    "message": f"Impossible de r√©soudre les placeholders {missing_alias} pour {generator_key}",
                    "missing": missing_alias,
                    "generator_key": generator_key
                }
            )
        if alias_actions:
            obs_logger.info(
                "event=alias_applied",
                event="alias_applied",
                outcome="success",
                alias_count=len(alias_actions),
                **ctx
            )
            logger.info(f"[PLACEHOLDER_ALIAS] Aliases appliqu√©s pour {generator_key}: {alias_actions}")

    raw_figure_type = all_vars.get("figure_type")
    figure_type = _normalize_figure_type(raw_figure_type)
    if figure_type:
        all_vars["figure_type"] = figure_type

    obs_logger.debug(
        "event=render_prepare",
        event="render_prepare",
        outcome="in_progress",
        figure_type_raw=raw_figure_type,
        available_keys_count=len(all_vars),
        **ctx
    )
    logger.info(
        f"[TESTS_DYN] format_dynamic_exercise: template_id={exercise_template.get('id')}, "
        f"exercise_id={exercise_id}, seed={seed}, generator={generator_key}, "
        f"difficulty={difficulty}, figure_type_raw={raw_figure_type}, figure_type={figure_type}"
    )
    logger.info(
        f"[TESTS_DYN] keys variables={sorted(list(variables.keys()))}, "
        f"results={sorted(list(results.keys()))}"
    )

    # =========================================================================
    # MAPPINGS DE COMPATIBILIT√â THALES (triangle / rectangle / carr√©)
    # =========================================================================
    # Objectif: ne JAMAIS laisser un template sans variable attendue,
    # uniquement en ajoutant des alias, sans modifier les valeurs sources.
    #
    # 1) triangle ‚Üí rectangle (base/hauteur -> longueur/largeur)
    if figure_type == "triangle":
        if "base_initiale" in all_vars:
            all_vars.setdefault("longueur_initiale", all_vars["base_initiale"])
        if "hauteur_initiale" in all_vars:
            all_vars.setdefault("largeur_initiale", all_vars["hauteur_initiale"])
        if "base_finale" in all_vars:
            all_vars.setdefault("longueur_finale", all_vars["base_finale"])
        if "hauteur_finale" in all_vars:
            all_vars.setdefault("largeur_finale", all_vars["hauteur_finale"])

    # 2) rectangle ‚Üí triangle (longueur/largeur -> base/hauteur)
    if figure_type == "rectangle":
        if "longueur_initiale" in all_vars:
            all_vars.setdefault("base_initiale", all_vars["longueur_initiale"])
        if "largeur_initiale" in all_vars:
            all_vars.setdefault("hauteur_initiale", all_vars["largeur_initiale"])
        if "longueur_finale" in all_vars:
            all_vars.setdefault("base_finale", all_vars["longueur_finale"])
        if "largeur_finale" in all_vars:
            all_vars.setdefault("hauteur_finale", all_vars["largeur_finale"])

    # 3) carr√© ‚Üí rectangle + triangle (cote -> longueur/largeur/base/hauteur)
    if figure_type == "carre":
        # Supporter quelques variantes de nommage √©ventuelles c√¥t√© g√©n√©rateur
        cote_initial = (
            all_vars.get("cote_initial")
            or all_vars.get("cote_initiale")
            or all_vars.get("side_initial")
            or all_vars.get("side")
        )
        cote_final = (
            all_vars.get("cote_final")
            or all_vars.get("cote_finale")
            or all_vars.get("side_final")
        )

        # Back-fill des cl√©s canoniques si seules les variantes existent
        if cote_initial is not None:
            all_vars.setdefault("cote_initial", cote_initial)
        if cote_final is not None:
            all_vars.setdefault("cote_final", cote_final)

        if cote_initial is not None:
            # Aliases rectangle
            all_vars.setdefault("longueur_initiale", cote_initial)
            all_vars.setdefault("largeur_initiale", cote_initial)
            # Aliases triangle
            all_vars.setdefault("base_initiale", cote_initial)
            all_vars.setdefault("hauteur_initiale", cote_initial)

        if cote_final is not None:
            # Aliases rectangle
            all_vars.setdefault("longueur_finale", cote_final)
            all_vars.setdefault("largeur_finale", cote_final)
            # Aliases triangle
            all_vars.setdefault("base_finale", cote_final)
            all_vars.setdefault("hauteur_finale", cote_final)

    # =========================================================================
    # G√âN√âRATION DES PLACEHOLDERS M√âTIER (answer, question)
    # =========================================================================
    # Placeholders m√©tier g√©n√©riques pour THALES : question/answer
    if generator_key and generator_key.startswith("THALES"):
        try:
            fig = all_vars.get("figure_type", "")
            # Valeurs fallback s√ªres
            cote_final = all_vars.get("cote_final")
            longueur_finale = all_vars.get("longueur_finale")
            largeur_finale = all_vars.get("largeur_finale")
            base_finale = all_vars.get("base_finale")
            hauteur_finale = all_vars.get("hauteur_finale")
            coef = all_vars.get("coefficient_str") or all_vars.get("coefficient")

            if fig == "carre" and cote_final is not None:
                all_vars["question"] = f"Quelle est la mesure du c√¥t√© final ?"
                all_vars["answer"] = f"{cote_final} cm"
            elif fig == "rectangle" and longueur_finale is not None and largeur_finale is not None:
                all_vars["question"] = "Quelles sont les dimensions du rectangle final ?"
                all_vars["answer"] = f"longueur {longueur_finale} cm, largeur {largeur_finale} cm"
            elif fig == "triangle" and base_finale is not None and hauteur_finale is not None:
                all_vars["question"] = "Quelles sont les dimensions du triangle final ?"
                all_vars["answer"] = f"base {base_finale} cm, hauteur {hauteur_finale} cm"
            else:
                # fallback g√©n√©rique pour ne pas bloquer le rendu
                all_vars["question"] = "Calcule les dimensions apr√®s transformation."
                all_vars["answer"] = f"coefficient {coef}" if coef is not None else "Voir calculs"
            logger.info(f"[TESTS_DYN] Placeholders m√©tier g√©n√©r√©s (question/answer) pour {generator_key} / figure={fig}")
        except Exception as e:
            logger.warning(f"[TESTS_DYN] Impossible de g√©n√©rer question/answer pour {generator_key}: {e}")

    # =========================================================================
    # S√âLECTION DU TEMPLATE (SINGLE OU VARIANTS)
    # =========================================================================
    # stable_key m√©tier pour la s√©lection de variant:
    # - soit fourni explicitement dans exercise_template["stable_key"]
    # - soit d√©riv√© du chapitre pilote + id local
    stable_key = exercise_template.get("stable_key") or f"6E_TESTS_DYN:{exercise_template.get('id')}"

    template_variants = exercise_template.get("template_variants") or []
    if template_variants:
        # =====================================================================
        # EXTRACTION chapter_code (obligatoire pour variants)
        # =====================================================================
        # Ne pas inventer chapter_code : soit pr√©sent dans exercise_template,
        # soit d√©riv√© depuis stable_key (format "{chapter_code}:{id}"),
        # sinon erreur explicite.
        chapter_code = exercise_template.get("chapter_code")
        
        # D√©rivation depuis stable_key si absent (format "{chapter_code}:{id}")
        if not chapter_code and stable_key:
            if ":" in stable_key:
                chapter_code = stable_key.split(":")[0]
        
        # Si toujours absent et variants pr√©sents ‚Üí erreur explicite
        if not chapter_code:
            logger.error(
                f"[VARIANTS_ALLOWLIST] chapter_code manquant pour template_variants. "
                f"Exercise template id={exercise_template.get('id')}, stable_key={stable_key}"
            )
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "MISSING_CHAPTER_CODE_FOR_VARIANTS",
                    "error": "missing_chapter_code_for_variants",
                    "message": (
                        "Le champ 'chapter_code' est requis pour utiliser template_variants. "
                        "Il doit √™tre pr√©sent dans exercise_template ou d√©rivable depuis stable_key."
                    ),
                    "exercise_template_id": exercise_template.get("id"),
                    "stable_key": stable_key,
                    "hint": "Ajoutez 'chapter_code' dans le template d'exercice ou utilisez un stable_key au format '{chapter_code}:{id}'."
                },
            )
        
        # =====================================================================
        # D√âTECTION AUTOMATIQUE TEMPLATE-BASED (Phase Finale)
        # =====================================================================
        # D√©tection automatique : chapitre template-based (compatible template_variants)
        # Z√©ro fallback silencieux : si spec-based ‚Üí erreur JSON explicite
        if not is_chapter_template_based(chapter_code, exercise_template):
            logger.error(
                f"[VARIANTS_AUTO_DETECTION] Chapitre '{chapter_code}' non template-based (spec-based). "
                f"Exercise template id={exercise_template.get('id')}, stable_key={stable_key}"
            )
            raise HTTPException(
                status_code=422,
                detail={
                    "error_code": "VARIANTS_NOT_SUPPORTED",
                    "error": "variants_not_supported",
                    "message": (
                        f"Les template_variants ne sont pas support√©s pour le chapitre '{chapter_code}'. "
                        f"Ce chapitre utilise une g√©n√©ration spec-based (MathGenerationService) "
                        f"et non template-based (is_dynamic=True + generator_key + enonce_template_html)."
                    ),
                    "chapter_code": chapter_code,
                    "exercise_template_id": exercise_template.get("id"),
                    "stable_key": stable_key,
                    "hint": "Les template_variants sont uniquement disponibles pour les chapitres template-based (avec is_dynamic=True + generator_key + enonce_template_html)."
                },
            )
        # IMPORTANT:
        # - D√®s que template_variants est non vide, ils deviennent la SEULE source de v√©rit√©
        #   pour le choix du template √©nonc√©/solution c√¥t√© √©l√®ve.
        # - Les champs legacy "enonce_template_html"/"solution_template_html" ne sont plus
        #   utilis√©s pour le rendu (uniquement miroir/compat √©ventuel c√¥t√© admin/DB).
        # On construit une liste d'objets avec les attributs attendus par choose_template_variant
        # IMPORTANT: Le champ 'id' est utilis√© pour la s√©lection fixed, il doit correspondre √† variant_id
        variant_objs: List[SimpleNamespace] = []
        for v in template_variants:
            if isinstance(v, dict):
                # Utiliser variant_id comme id si pr√©sent, sinon id
                variant_id = v.get("variant_id") or v.get("id")
                variant_objs.append(
                    SimpleNamespace(
                        id=variant_id,  # Utilis√© pour la s√©lection fixed
                        variant_id=variant_id,  # Pour tra√ßabilit√©
                        enonce_template_html=v.get("enonce_template_html", ""),
                        solution_template_html=v.get("solution_template_html", ""),
                        weight=v.get("weight", 1),
                    )
                )
            else:
                # Si d√©j√† un objet avec les bons attributs, on le garde tel quel
                variant_objs.append(v)  # type: ignore[arg-type]

        # S√©lection d√©terministe si variant_id pr√©sent dans exercise_params
        variant_id_from_params = exercise_params.get("variant_id")
        if variant_id_from_params:
            # S√©lection d√©terministe via mode="fixed"
            try:
                chosen_variant = choose_template_variant(
                    variants=variant_objs,
                    seed=seed,
                    exercise_id=stable_key,
                    mode="fixed",
                    fixed_variant_id=variant_id_from_params
                )
                variant_id = variant_id_from_params  # Utiliser celui fourni
                obs_logger.info(
                    "event=variant_fixed_selected",
                    event="variant_fixed_selected",
                    outcome="success",
                    variant_id=variant_id,
                    variants_count=len(variant_objs),
                    **ctx
                )
            except ValueError as e:
                # Variant non trouv√© ‚Üí erreur explicite
                obs_logger.error(
                    "event=variant_fixed_error",
                    event="variant_fixed_error",
                    outcome="error",
                    reason="variant_id_not_found",
                    variant_id_requested=variant_id_from_params,
                    available_variant_ids=[getattr(v, 'id', None) for v in variant_objs],
                    **ctx
                )
                available_variant_ids = [getattr(v, 'id', None) for v in variant_objs]
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "VARIANT_ID_NOT_FOUND",
                        "error": "variant_id_not_found",
                        "message": f"Le variant_id '{variant_id_from_params}' n'a pas √©t√© trouv√© dans les template_variants.",
                        "hint": f"Les variants disponibles sont : {', '.join(map(str, available_variant_ids))}. V√©rifiez que le variant_id demand√© existe pour cet exercice.",
                        "context": {
                            "exercise_id": exercise_template.get("id"),
                            "variant_id_requested": variant_id_from_params,
                            "variants_present": available_variant_ids
                        }
                    }
                )
        else:
            # Fallback d√©terministe quand variant_id absent (compatibilit√© legacy)
            # S√©lectionner le premier variant disponible de mani√®re d√©terministe
            if not variant_objs:
                # Aucun variant disponible ‚Üí erreur explicite
                obs_logger.error(
                    "event=variant_no_variants_available",
                    event="variant_no_variants_available",
                    outcome="error",
                    reason="no_variants_in_template",
                    **ctx
                )
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "NO_VARIANTS_AVAILABLE",
                        "error": "no_variants_available",
                        "message": "Aucun template_variant disponible pour cet exercice.",
                        "exercise_template_id": exercise_template.get("id"),
                    }
                )
            
            # S√©lectionner le premier variant de mani√®re d√©terministe (mode="fixed")
            available_variant_ids = [getattr(v, 'id', None) for v in variant_objs]
            fallback_variant_id = available_variant_ids[0] if available_variant_ids else None
            
            if fallback_variant_id:
                chosen_variant = choose_template_variant(
                    variants=variant_objs,
                    seed=seed,
                    exercise_id=stable_key,
                    mode="fixed",
                    fixed_variant_id=fallback_variant_id
                )
                variant_id = getattr(chosen_variant, 'variant_id', None) or fallback_variant_id
                obs_logger.info(
                    "event=variant_fallback_selected",
                    event="variant_fallback_selected",
                    outcome="success",
                    reason="variant_id_absent",
                    variant_id=variant_id,
                    fallback_variant_id=fallback_variant_id,
                    variants_count=len(variant_objs),
                    **ctx
                )
            else:
                # Cas de s√©curit√© : aucun variant_id disponible
                obs_logger.error(
                    "event=variant_no_id_available",
                    event="variant_no_id_available",
                    outcome="error",
                    reason="no_variant_id_in_variants",
                    **ctx
                )
                raise HTTPException(
                    status_code=422,
                    detail={
                        "error_code": "NO_VARIANT_ID_AVAILABLE",
                        "error": "no_variant_id_available",
                        "message": "Aucun variant_id disponible dans les template_variants.",
                        "exercise_template_id": exercise_template.get("id"),
                    }
                )

        # Log variant s√©lectionn√© (apr√®s s√©lection fixe ou fallback)
        obs_logger.info(
            "event=variant_selected",
            event="variant_selected",
            outcome="success",
            variant_id=variant_id,
            variants_count=len(variant_objs),
            **ctx
        )

        enonce_template = chosen_variant.enonce_template_html
        solution_template = chosen_variant.solution_template_html
    else:
        # Fallback: comportement legacy, un seul template par exercice
        enonce_template = exercise_template.get("enonce_template_html", "")
        solution_template = exercise_template.get("solution_template_html", "")
    
    # =========================================================================
    # DEBUG: placeholders attendus vs variables fournies
    # =========================================================================
    placeholders_enonce = _extract_placeholders(enonce_template)
    placeholders_solution = _extract_placeholders(solution_template)
    expected_placeholders = placeholders_enonce.union(placeholders_solution)
    provided_keys = set(all_vars.keys())
    missing_before_render = sorted(expected_placeholders - provided_keys)

    if expected_placeholders:
        obs_logger.debug(
            "event=placeholders_analysis",
            event="placeholders_analysis",
            outcome="in_progress",
            expected_count=len(expected_placeholders),
            provided_count=len(provided_keys),
            missing_before_render_count=len(missing_before_render),
            **ctx
        )
        logger.info(
            f"[TESTS_DYN] Placeholders attendus (ex {exercise_template.get('id')} "
            f"/ {generator_key} / {figure_type}): {sorted(expected_placeholders)} | "
            f"cl√©s fournies avant mapping: {sorted(provided_keys)} | "
            f"manquantes avant rendu: {missing_before_render}"
        )

    # Rendu HTML
    enonce_html = render_template(enonce_template, all_vars)
    solution_html = render_template(solution_template, all_vars)
    
    # =========================================================================
    # GUARDE ANTI-PLACEHOLDERS: ne jamais renvoyer {{...}} c√¥t√© √©l√®ve
    # =========================================================================
    unresolved_enonce = re.findall(r"\{\{\s*(\w+)\s*\}\}", enonce_html or "")
    unresolved_solution = re.findall(r"\{\{\s*(\w+)\s*\}\}", solution_html or "")
    unresolved = sorted(set(unresolved_enonce + unresolved_solution))

    if unresolved:
        # Log unresolved placeholders avec les bonnes informations
        obs_logger.error(
            "event=unresolved_placeholders",
            event="unresolved_placeholders",
            outcome="error",
            reason="placeholders_422",
            missing_placeholders=",".join(unresolved),
            available_keys_count=len(provided_keys),
            expected_count=len(expected_placeholders),
            **ctx
        )
        
        # Construire le message hint explicatif
        missing_list = ", ".join(unresolved[:5])  # Limiter √† 5 pour la lisibilit√©
        if len(unresolved) > 5:
            missing_list += f" et {len(unresolved) - 5} autre(s)"
        
        hint = (
            f"Les placeholders suivants n'ont pas pu √™tre r√©solus : {missing_list}. "
            f"V√©rifiez que le g√©n√©rateur '{generator_key}' fournit toutes les variables n√©cessaires pour le template. "
            f"Placeholders attendus : {len(expected_placeholders)}, fournis : {len(provided_keys)}."
        )

        logger.error(
            f"[TESTS_DYN] PLACEHOLDER_UNRESOLVED pour ex {exercise_id} "
            f"(template {exercise_template.get('id')}, generator={generator_key}, figure_type={figure_type}) - "
            f"restants: {unresolved} | attendus: {sorted(expected_placeholders)} | cl√©s: {sorted(provided_keys)}"
        )

        # Remonter une erreur structur√©e JSON-safe avec format standardis√©
        raise HTTPException(
            status_code=422,
            detail={
                "error_code": "PLACEHOLDER_UNRESOLVED",
                "error": "placeholder_unresolved",
                "message": f"Un ou plusieurs placeholders n'ont pas √©t√© r√©solus pour {chapter_code}.",
                "hint": hint,
                "context": {
                    "chapter_code": chapter_code,
                    "missing": unresolved,
                    "template_id": exercise_template.get("id"),
                    "generator_key": generator_key,
                    "expected_placeholders": sorted(expected_placeholders),
                    "provided_keys": sorted(provided_keys)
                }
            },
        )
    
    # Log succ√®s handler
    handler_duration_ms = int((time.time() - handler_start) * 1000)
    obs_logger.info(
        "event=handler_complete",
        event="handler_complete",
        outcome="success",
        duration_ms=handler_duration_ms,
        **ctx
    )
    
    return {
        "id_exercice": exercise_id,
        "niveau": "6e",
        "chapitre": chapter_code,
        "enonce_html": enonce_html,
        "solution_html": solution_html,
        "figure_svg": gen_result.get("figure_svg_enonce"),
        "figure_svg_enonce": gen_result.get("figure_svg_enonce"),
        "figure_svg_solution": gen_result.get("figure_svg_solution"),
        "svg": gen_result.get("figure_svg_enonce"),
        "pdf_token": exercise_id,
        "metadata": {
            "code_officiel": chapter_code,
            "difficulte": difficulty,
            "difficulty": difficulty,
            "is_premium": is_premium,
            "offer": "pro" if is_premium else "free",
            "generator_code": f"{chapter_code}_{generator_key}",
            "family": exercise_template["family"],
            "exercise_type": exercise_template.get("exercise_type"),
            "exercise_id": exercise_template["id"],
            "is_dynamic": True,
            "generator_key": generator_key,
            "seed_used": seed,
            "variables": variables,
            "variables_used": {"source": "generator", **variables},
            "source": "dynamic_generator",
            "needs_svg": exercise_template.get("needs_svg", True)
        }
    }


def generate_tests_dyn_exercise(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None,
    seed: Optional[int] = None
) -> Optional[Dict[str, Any]]:
    """
    G√©n√®re UN exercice dynamique.
    
    Args:
        offer: "free" ou "pro" (fallback automatique vers "free" si aucun exercice "pro")
        difficulty: "facile", "moyen", "difficile"
        seed: Graine pour reproductibilit√© (utilis√©e tel quel, sans d√©rivation)
    
    Returns:
        Exercice format√© pour l'API ou None si aucun exercice disponible
    """
    offer = (offer or "free").lower()
    if difficulty:
        difficulty = difficulty.lower()
    
    # S√©lectionner un template (le fallback pro‚Üífree est g√©r√© dans get_tests_dyn_exercises)
    exercise_template = get_random_tests_dyn_exercise(
        offer=offer,
        difficulty=difficulty,
        seed=seed
    )
    
    if not exercise_template:
        return None
    
    timestamp = int(time.time() * 1000)
    
    # Utiliser le seed tel quel pour garantir le d√©terminisme
    # M√™me seed + m√™mes params = m√™me r√©sultat
    gen_seed = seed if seed is not None else timestamp
    
    return format_dynamic_exercise(exercise_template, timestamp, seed=gen_seed)


def generate_tests_dyn_batch(
    offer: Optional[str] = None,
    difficulty: Optional[str] = None,
    count: int = 1,
    seed: Optional[int] = None
) -> tuple:
    """
    G√©n√®re un batch d'exercices dynamiques.
    
    Chaque exercice utilise un seed diff√©rent pour des variantes uniques.
    
    Args:
        offer: "free" ou "pro"
        difficulty: "facile", "moyen", "difficile"
        count: Nombre d'exercices souhait√©s
        seed: Graine de base pour reproductibilit√©
    
    Returns:
        Tuple (exercises, batch_info)
    """
    offer = (offer or "free").lower()
    if difficulty:
        difficulty = difficulty.lower()
    
    # R√©cup√©rer les templates disponibles
    templates, info = get_tests_dyn_batch(
        offer=offer,
        difficulty=difficulty,
        count=count,
        seed=seed
    )
    
    if not templates:
        return [], {
            "requested": count,
            "available": 0,
            "returned": 0,
            "filters": {"offer": offer, "difficulty": difficulty},
            "is_dynamic": True
        }
    
    timestamp = int(time.time() * 1000)
    exercises = []
    
    for i, template in enumerate(templates):
        # Seed unique pour chaque exercice, mais d√©terministe
        # Utiliser seed + i pour garantir l'unicit√© tout en restant d√©terministe
        ex_seed = (seed + i) if seed is not None else (timestamp + i)
        
        formatted = format_dynamic_exercise(template, timestamp + i, seed=ex_seed)
        exercises.append(formatted)
    
    batch_info = {
        "requested": count,
        "available": info["available"],
        "returned": len(exercises),
        "filters": {"offer": offer, "difficulty": difficulty},
        "is_dynamic": True,
        "generator_used": "THALES_V1"
    }
    
    return exercises, batch_info


def get_available_generators() -> List[str]:
    """Retourne la liste des g√©n√©rateurs disponibles."""
    # R√©cup√©rer les g√©n√©rateurs legacy
    legacy_generators = list(GENERATORS_REGISTRY.keys())
    
    # R√©cup√©rer les g√©n√©rateurs de la Factory
    try:
        from backend.generators.factory import get_generators_list
        factory_generators = get_generators_list()
        factory_keys = [g["key"] for g in factory_generators]
    except Exception:
        factory_keys = []
    
    # Fusionner et d√©dupliquer
    all_generators = list(set(legacy_generators + factory_keys))
    return sorted(all_generators)


if __name__ == "__main__":
    # Test rapide
    print("=== TEST HANDLER TESTS_DYN ===")
    
    # Test single
    ex = generate_tests_dyn_exercise(offer="free", difficulty="moyen", seed=42)
    if ex:
        print(f"‚úÖ Single: {ex['id_exercice']}")
        print(f"   √ânonc√©: {ex['enonce_html'][:100]}...")
        print(f"   Variables: {ex['metadata']['variables']}")
    
    # Test batch
    exercises, info = generate_tests_dyn_batch(offer="free", count=3, seed=123)
    print(f"\n‚úÖ Batch: {info['returned']}/{info['requested']} exercices")
    for ex in exercises:
        print(f"   - {ex['id_exercice']}: {ex['metadata']['variables'].get('coefficient', 'N/A')}")

# ============================================================================
# 6. backend/utils/difficulty_utils.py (normalisation)
# ============================================================================

"""
Utilitaires pour la normalisation et la gestion des difficult√©s.

P4.B - Standardisation des difficult√©s : facile / moyen / difficile
Mapping : standard -> moyen (pour compatibilit√©)
"""

from typing import Literal

# Difficult√©s canoniques (affich√©es dans l'UI)
CANONICAL_DIFFICULTIES = ["facile", "moyen", "difficile"]

# Mapping de compatibilit√© (anciennes valeurs -> canoniques)
DIFFICULTY_MAPPING = {
    "standard": "moyen",  # P4.B: standard est mapp√© vers moyen
    "facile": "facile",
    "moyen": "moyen",
    "difficile": "difficile",
    # P4.C - Mappings suppl√©mentaires
    "hard": "difficile",
    "advanced": "difficile",
    "easy": "facile",
    "medium": "moyen",
}


def normalize_difficulty(difficulty: str) -> str:
    """
    Normalise une difficult√© vers la forme canonique.
    
    Mapping:
    - "standard" -> "moyen"
    - "facile" -> "facile"
    - "moyen" -> "moyen"
    - "difficile" -> "difficile"
    
    Args:
        difficulty: Difficult√© √† normaliser (peut √™tre "standard", "facile", "moyen", "difficile")
    
    Returns:
        Difficult√© canonique ("facile", "moyen", ou "difficile")
    
    Raises:
        ValueError: Si la difficult√© n'est pas reconnue
    """
    if not difficulty:
        return "moyen"  # Par d√©faut
    
    difficulty_lower = difficulty.lower().strip()
    
    # Mapping explicite
    if difficulty_lower in DIFFICULTY_MAPPING:
        return DIFFICULTY_MAPPING[difficulty_lower]
    
    # Si d√©j√† canonique, retourner tel quel
    if difficulty_lower in CANONICAL_DIFFICULTIES:
        return difficulty_lower
    
    # Valeur non reconnue
    raise ValueError(
        f"Difficult√© non reconnue: '{difficulty}'. "
        f"Valeurs accept√©es: {', '.join(CANONICAL_DIFFICULTIES + ['standard'])}"
    )


def is_canonical_difficulty(difficulty: str) -> bool:
    """
    V√©rifie si une difficult√© est canonique (facile, moyen, difficile).
    
    Args:
        difficulty: Difficult√© √† v√©rifier
    
    Returns:
        True si la difficult√© est canonique, False sinon
    """
    return difficulty.lower() in CANONICAL_DIFFICULTIES


def get_all_canonical_difficulties() -> list[str]:
    """
    Retourne la liste de toutes les difficult√©s canoniques.
    
    Returns:
        Liste des difficult√©s canoniques: ["facile", "moyen", "difficile"]
    """
    return CANONICAL_DIFFICULTIES.copy()


def coerce_to_supported_difficulty(
    requested: str,
    supported: list[str],
    logger=None
) -> str:
    """
    Coerce une difficult√© demand√©e vers une difficult√© support√©e par le g√©n√©rateur.
    
    R√®gle de fallback :
    - Si requested ‚àà supported ‚Üí retourne requested (normalis√©e)
    - Sinon fallback par d√©faut :
      - difficile ‚Üí moyen (si moyen ‚àà supported)
      - moyen ‚Üí facile (si facile ‚àà supported)
      - facile ‚Üí facile (toujours support√©)
    
    Args:
        requested: Difficult√© demand√©e (sera normalis√©e d'abord)
        supported: Liste des difficult√©s support√©es par le g√©n√©rateur (doivent √™tre canoniques)
        logger: Logger optionnel pour enregistrer la coercition
    
    Returns:
        Difficult√© support√©e (canonique)
    
    Example:
        >>> coerce_to_supported_difficulty("difficile", ["facile", "moyen"])
        "moyen"  # Fallback difficile ‚Üí moyen
    """
    # Normaliser la difficult√© demand√©e
    requested_normalized = normalize_difficulty(requested)
    
    # Normaliser les difficult√©s support√©es
    supported_normalized = [normalize_difficulty(d) for d in supported]
    
    # Si la difficult√© demand√©e est support√©e, la retourner
    if requested_normalized in supported_normalized:
        return requested_normalized
    
    # Fallback hi√©rarchique
    if requested_normalized == "difficile":
        # difficile ‚Üí moyen (si disponible)
        if "moyen" in supported_normalized:
            if logger:
                logger.info(
                    f"[DIFFICULTY_COERCED] requested=difficile coerced_to=moyen "
                    f"(generator supports: {supported_normalized})"
                )
            return "moyen"
        # Sinon ‚Üí facile
        if "facile" in supported_normalized:
            if logger:
                logger.info(
                    f"[DIFFICULTY_COERCED] requested=difficile coerced_to=facile "
                    f"(generator supports: {supported_normalized})"
                )
            return "facile"
    
    elif requested_normalized == "moyen":
        # moyen ‚Üí facile (si disponible)
        if "facile" in supported_normalized:
            if logger:
                logger.info(
                    f"[DIFFICULTY_COERCED] requested=moyen coerced_to=facile "
                    f"(generator supports: {supported_normalized})"
                )
            return "facile"
    
    # Si aucune difficult√© n'est support√©e (cas th√©orique), retourner facile par d√©faut
    if logger:
        logger.warning(
            f"[DIFFICULTY_COERCED] requested={requested_normalized} coerced_to=facile "
            f"(fallback ultime, generator supports: {supported_normalized})"
        )
    return "facile"


def map_ui_difficulty_to_generator(
    generator_key: str,
    ui_difficulty: str,
    logger=None
) -> str:
    """
    P4.D HOTFIX - Mappe une difficult√© UI (canonique) vers la difficult√© r√©elle du g√©n√©rateur.
    
    Probl√®me r√©solu :
    - UI utilise facile/moyen/difficile (canoniques)
    - Certains g√©n√©rateurs utilisent facile/standard (non canonique)
    - normalize_difficulty() convertit standard -> moyen (pour l'UI)
    - Mais le g√©n√©rateur attend "standard", pas "moyen"
    
    Solution :
    - R√©cup√®re les difficult√©s r√©ellement support√©es par le g√©n√©rateur
    - Mappe intelligemment :
      - ui_difficulty == "moyen" et g√©n√©rateur supporte "standard" -> retourne "standard"
      - ui_difficulty == "difficile" et non support√© -> fallback vers "standard" si pr√©sent, sinon "facile"
      - Sinon retourne ui_difficulty normalis√©e
    
    Args:
        generator_key: Cl√© du g√©n√©rateur (ex: "CALCUL_NOMBRES_V1")
        ui_difficulty: Difficult√© UI canonique (facile/moyen/difficile)
        logger: Logger optionnel pour enregistrer le mapping
    
    Returns:
        Difficult√© r√©elle √† utiliser pour le g√©n√©rateur (peut √™tre "standard" au lieu de "moyen")
    
    Example:
        >>> map_ui_difficulty_to_generator("CALCUL_NOMBRES_V1", "moyen")
        "standard"  # Car CALCUL_NOMBRES_V1 supporte facile/standard, pas moyen
    """
    from backend.generators.factory import GeneratorFactory
    
    # Normaliser la difficult√© UI
    ui_normalized = normalize_difficulty(ui_difficulty)
    
    # R√©cup√©rer le g√©n√©rateur
    gen_class = GeneratorFactory.get(generator_key)
    if not gen_class:
        # G√©n√©rateur introuvable, retourner la difficult√© normalis√©e
        if logger:
            logger.warning(
                f"[DIFFICULTY_MAPPING] G√©n√©rateur '{generator_key}' introuvable, "
                f"utilisation de la difficult√© UI normalis√©e: {ui_normalized}"
            )
        return ui_normalized
    
    # R√©cup√©rer les difficult√©s support√©es depuis le sch√©ma
    schema = gen_class.get_schema()
    supported_difficulties = []
    
    if schema:
        difficulty_param = next((p for p in schema if p.name == "difficulty"), None)
        if difficulty_param and hasattr(difficulty_param, 'options'):
            supported_difficulties = difficulty_param.options or []
    
    # Si aucune difficult√© support√©e trouv√©e, retourner la difficult√© normalis√©e
    if not supported_difficulties:
        if logger:
            logger.warning(
                f"[DIFFICULTY_MAPPING] Aucune difficult√© support√©e trouv√©e pour '{generator_key}', "
                f"utilisation de la difficult√© UI normalis√©e: {ui_normalized}"
            )
        return ui_normalized
    
    # Convertir les difficult√©s support√©es en minuscules pour comparaison
    supported_lower = [d.lower().strip() for d in supported_difficulties]
    
    # Si la difficult√© UI normalis√©e est directement support√©e, la retourner
    if ui_normalized in supported_lower:
        return ui_normalized
    
    # Mapping sp√©cial : "moyen" UI -> "standard" g√©n√©rateur
    if ui_normalized == "moyen" and "standard" in supported_lower:
        if logger:
            logger.info(
                f"[DIFFICULTY_MAPPED] generator={generator_key} ui=moyen -> generator=standard "
                f"(supported: {supported_difficulties})"
            )
        return "standard"
    
    # Fallback pour "difficile" UI
    if ui_normalized == "difficile":
        # Essayer "standard" d'abord
        if "standard" in supported_lower:
            if logger:
                logger.info(
                    f"[DIFFICULTY_MAPPED] generator={generator_key} ui=difficile -> generator=standard "
                    f"(fallback, supported: {supported_difficulties})"
                )
            return "standard"
        # Sinon "facile"
        if "facile" in supported_lower:
            if logger:
                logger.info(
                    f"[DIFFICULTY_MAPPED] generator={generator_key} ui=difficile -> generator=facile "
                    f"(fallback, supported: {supported_difficulties})"
                )
            return "facile"
    
    # Fallback pour "moyen" UI si "standard" n'est pas support√©
    if ui_normalized == "moyen" and "facile" in supported_lower:
        if logger:
            logger.info(
                f"[DIFFICULTY_MAPPED] generator={generator_key} ui=moyen -> generator=facile "
                f"(fallback, supported: {supported_difficulties})"
            )
        return "facile"
    
    # Aucun mapping trouv√©, retourner la difficult√© normalis√©e (g√©n√©rera probablement une erreur)
    if logger:
        logger.warning(
            f"[DIFFICULTY_MAPPED] generator={generator_key} ui={ui_normalized} -> generator={ui_normalized} "
            f"(aucun mapping trouv√©, supported: {supported_difficulties})"
        )
    return ui_normalized


def auto_complete_presets(
    requested_presets: list[str],
    supported_difficulties: list[str]
) -> list[str]:
    """
    Auto-compl√®te les presets de difficult√©s en ajoutant les manquantes.
    
    Si une difficult√© canonique manque dans requested_presets, elle est ajout√©e
    en clonant la difficult√© la plus proche disponible.
    
    R√®gle :
    - facile, moyen, difficile sont toujours pr√©sents dans le r√©sultat
    - Si "difficile" manque ‚Üí ajouter "difficile" (m√™me si non support√©e nativement)
    - Si "moyen" manque ‚Üí ajouter "moyen"
    - Si "facile" manque ‚Üí ajouter "facile"
    
    Args:
        requested_presets: Liste des difficult√©s demand√©es (seront normalis√©es)
        supported_difficulties: Liste des difficult√©s support√©es par le g√©n√©rateur
    
    Returns:
        Liste compl√©t√©e avec toutes les difficult√©s canoniques
    """
    # Normaliser les presets demand√©s
    requested_normalized = [normalize_difficulty(d) for d in requested_presets]
    
    # Normaliser les difficult√©s support√©es
    supported_normalized = [normalize_difficulty(d) for d in supported_difficulties]
    
    # Commencer avec les presets demand√©s
    result = list(set(requested_normalized))  # D√©dupliquer
    
    # Ajouter les difficult√©s canoniques manquantes
    for canonical in CANONICAL_DIFFICULTIES:
        if canonical not in result:
            result.append(canonical)
    
    # Trier pour avoir un ordre coh√©rent
    result.sort(key=lambda x: CANONICAL_DIFFICULTIES.index(x))
    
    return result

